
-- My modded version of inflammation.
-- Thanks: Bagof & TrustySn00ze
-- Bagof: made a flood infection mod which inspired some class ideas seen in this one (player parasite and suicide bomb jetpack).
-- TrustySn00ze: combined invasion and infection into one gametype (inflammation).


---- keywords
-- mfix = something which will probably need fixing or changing for multiplayer
-- stest = something which is only here for testing in singleplayer. needs to be removed in the end.
-- object saving = somewhere that you could change to save number of objects, to prevent map overloading.
-- redundancy = somewhere you can change to save script space.
-- luxury = something which is gravy/unimportant feature which can be removed for script space.
-- parasite OR skull = something to do with infection skull ai
-- crashes/crashing = something likely to cause crashing in multiplayer



--- form ID aliases
alias carrier_ID = 4
alias ballooning_ID = 14
alias exploding_carrier_ID = -4
alias p_parasite_ID = 26
alias combat_ID = 5
alias stalker_ranger_ID = 19
alias mutating_ID = 110
alias juggernaut_ID = 99
alias reanimating_ID = 110
alias swarm_ID = 33

alias bloat_bomb_type = bomb

alias host_indicator = team[1].number[7] -- used in figuring out which machine running 'local' is the host machine

alias phase_team = team[3].team[1]
alias p1 = team[0]
alias p2 = team[1]
alias p3 = team[2]

alias incubation = object.number[4]    -- needs a high priority variable I reckon.
alias incubation_ready = 1200
alias local_current_biped = global.object[12]

alias host_ID = 1
alias local_ID = 1         -- Flood singleplayer testing: change from 0 to 1.    Elite testing.

alias Parasite_Eruption_Round = global.number[5]             -- global.object[4].number[3]      <-- swapped with core script global.number[5]   (used for sudden death ending).   
alias global_tick_counter = team[0].number[7]


declare global.number[0] with network priority local
declare global.number[1] with network priority local
declare global.number[2] with network priority low = 1
--declare global.number[3] with network priority low = -1
declare global.number[4] with network priority local = -1
--declare global.number[5] with network priority low = 10
declare global.number[5] with network priority local
declare global.number[6] with network priority local			-- scale local tick counter
declare global.number[7] with network priority local        -- client tick limiter (every 10th tick)
declare global.number[8] with network priority local
declare global.number[9] with network priority local
declare global.number[10] with network priority local			-- temporary
declare global.number[11] with network priority local			-- temporary. used for counting total players for alpha zombies counts, my balance scaling additions, and temporary for spec ops powerup.
declare global.object[0] with network priority low
declare global.object[1] with network priority local
declare global.object[2] with network priority local
declare global.object[3] with network priority local				-- my temporary
declare global.object[4] with network priority high		--low			-- my script-spawned master hill marker control box (for creating more global numbers)
declare global.object[5] with network priority local				-- my temporary
declare global.object[6] with network priority local				-- my temporary
declare global.object[7] with network priority local				-- my temporary
declare global.object[11] with network priority local				-- my client master hill marker
declare global.object[12] with network priority local				-- used for portable shield. used to use global.object[3] but that sometimes caused respawn fuckery bluescreen for elites.
declare global.object[13] with network priority local				-- used for portable shield. used to use global.object[3] but that sometimes caused respawn fuckery bluescreen for elites.
declare global.object[14] with network priority high				-- needs to be high for widget supposedly.
declare global.object[15] with network priority local				-- needs to be high for widget supposedly.
declare global.player[0] with network priority low
declare global.player[1] with network priority low
declare global.player[2] with network priority local
declare global.player[3] with network priority local
declare global.player[4] with network priority local
declare global.player[5] with network priority local				-- the_local_player
declare global.team[0] with network priority low = team[1]     -- does this sync to clients?
declare global.team[1] with network priority low = team[0]
declare global.team[2] with network priority local
--declare team[0] with network priority low
--declare team[1] with network priority low = team[0]
declare global.team[5] with network priority local = team[0]		-- just for extra global.timers off a team. for bombs.
--declare global.timer[0] = 35
--declare global.timer[0] = 10        -- skullamanjaro announcement
declare global.timer[1] = 10
declare global.timer[2] = 11
declare global.timer[3] = 11
declare global.timer[4] = 4
declare global.timer[5] = 3
declare global.timer[6] = 3
declare global.timer[7] = 10
declare player.number[0] with network priority low
declare player.number[1] with network priority low             -- zombie state: 0 is survivor, -3 is monitor, 1 is zombie.
declare player.number[2] with network priority low
declare player.number[3] with network priority low					-- used for late joiner initial spawn point killing. used to be alpha zombie ID (no longer needed).
declare player.number[4] with network priority low
declare player.number[5] with network priority local				-- first tick infected marker
declare player.number[6] with network priority local				-- dead tick counter (for respawning flood to possess writhing corpses). 
declare player.number[7] with network priority local           -- player has a nominated writhing corpse awaiting. changes to 7 when dibbsed
-- WARNING. player.timer[0] isn't declared but it is in use in the script. don't try to use it.
declare player.timer[1] = 5
declare player.timer[2] = 1
declare object.number[0] with network priority low
declare object.number[1] with network priority local
declare object.number[2] with network priority local
declare object.number[3] with network priority low
declare object.number[4] with network priority high		-- was low. Changed to high because I'm now using global.object[4].number[4] as a pseudo global number tick counter, for once-per-second scaling
declare object.number[5] with network priority high 		-- Flood stuff.      -- changed from low to high so that bar progress is smooth for clients when "fresh biomass!"
declare object.number[6] with network priority high		-- set_scale for script use.
declare object.number[7] with network priority high		-- added in v23, before it wasn't mentioned, I'm amazed anything worked without this!
declare object.object[0] with network priority low
declare object.object[1] with network priority low
declare object.object[2] with network priority local
--declare object.object[3] with network priority local	-- local player crosshair target biped. do not use player biped.object[3] for anything else on biped.            old:grunt secondary, for deleting fuel rod on death.
declare object.object[3] with network priority high      -- biped's bomb for corpse syncing.          -- migth cause problems now i've changed this local variable to a high one.
declare object.player[0] with network priority high	-- a body's most recent owner. used for parasite kill credit / daddy
declare object.player[1] with network priority high	-- a writhing body's player to be respawned.          -- local.
declare player.object[0] with network priority local	-- most recent elite biped, for grunt backpack explosion
declare player.object[2] with network priority high	-- leap bomb. increased from default to high in v29, hoping to make it get detected faster for more responsive leap and faster bomb size down.
declare player.object[3] with network priority local	-- local player crosshair target biped. do not use player player.object[3] for anything else.

declare player.player[1] with network priority local	-- kill credit when killed by an parasite with a daddy

declare object.timer[0] = 60
declare object.timer[1] = 60
declare object.timer[2] = 10
declare object.timer[3] = 30
declare object.team[0] with network priority low      -- for local alarms with team phase number
declare team.number[0] with network priority local    -- points score
declare team.number[1] with network priority low
declare team.number[2] with network priority low
declare team.number[3] with network priority high     -- low. changed to high for swarm max count.
declare team.number[4] with network priority local     -- "your parasites", changed to local.       old: core now unused (used to be when defender team swapping was allowed)
declare team.number[5] with network priority high       -- "total parasites"        -- core uses for team[1]. otherwise unused       -- lo2
declare team.number[6] with network priority low		-- my added.      -- old: used as a pseudo global.number / tick counter for bomb rumble screenshake effect.
declare team.number[7] with network priority local		--  my added      -- host_indicator.               -- old. fireteam designator
declare team.object[0] with network priority low
declare team.object[1] with network priority low
declare team.timer[0] = 30
declare team.timer[1] = 15
declare team.team[1] = team[0]       -- team[3].team is phase number. Phase 1 is red, phase 2 is blue, phase 3 is green, phase 4 is orange. change objective team to the right one.

alias host_existance_check = global.timer[3]




--for each object do
   --if current_object.is_of_type(covenant_power_core) then
      --current_object.delete()
   --end
--end


---- Deletions v2:  action cheap, condition expensive. 
-- delete hidden bodies   +   corpse syncing bomb   +   dropped swords, needle_rifle, spiker
for each object do
   if current_object.number[7] >= 4373 and current_object.number[7] <= 4444 then
      --current_object.timer[2].set_rate(-125%)
      --current_object.set_waypoint_visibility(everyone)         -- testing.
      global.player[4] = current_object.try_get_carrier()
      if global.player[4].team != team[1] and current_object.object[3] == no_object and current_object.timer[2].is_zero() or current_object.number[7] != 4373 or current_object.is_of_type(bloat_bomb_type) then
         current_object.delete()
      end
   end
end



--for each object do
   --if current_object.is_of_type(spiker) then
      --current_object.detach()
   --end
--end



----- loadout camera changing: round = spawn sequence
--do
--   global.number[10] = game.current_round
--end

--for each object do
--   if current_object.is_of_type(initial_loadout_camera) and current_object.spawn_sequence == 2 then
--      global.object[8] = current_object
--	  for each object do
 --        if current_object.is_of_type(initial_loadout_camera) and current_object != global.object[8] then
--		    current_object.delete()
 --        end
--	  end
 --  end
--end

--function primary_respawn()
   --for each player do
      --if current_player.team == current_object.team then
         --current_player.set_primary_respawn_object(global.object[8])
      --end
   --end
--end

--function Auto11A0454B_291()
   --current_object.set_spawn_location_permissions(allies)
   --current_object.set_spawn_location_fireteams(all)
   --global.object[8] = current_object
   --primary_respawn()
--end

-------- One row initial spawn point duplication. ultra short.
function propogate()
   if current_object.number[0] < current_object.spawn_sequence then
      global.object[8] = global.object[8].place_at_me(initial_spawn_point, "inv_gates", none, 0, 9, 0, none)      -- changed from 7.
      global.object[8].team = current_object.team
      current_object.number[0] += 1
      --global.object[8] = current_object.place_at_me(spartan,none,none,10,0,5,none)     -- NPC testing
      propogate()
   end
end
for each object with label "inv_gates" do
   if current_object.is_of_type(initial_spawn_point) and current_object.spawn_sequence > 0 and current_object.number[0] == 0 then		-- for grids you don't want to duplicate, make pink team.
      global.object[8] = current_object
      propogate()
   end
end

-- humans just fireteam spawn. simple. 
team[0].set_co_op_spawning(true)
team[1].set_co_op_spawning(false)      -- necessary
-- infected team use traditional respawn points. This is because I want max body spectate times for resurrection and for carrier explosion.


------ bomb rumble effect /screen shake v3: 2 random timespans
-- removed.




on pregame: do
   game.symmetry = 0
end

on init: do    --if global.number[2] == 1 then 			-- maybe redundant condition
   --global.timer[0].set_rate(-100%)        -- skullamanjaro announcement
   Parasite_Eruption_Round = rand(2)      -- CHANGE BACK TO 5.    Nah. More fun as 50% I'd say.
   --global.number[8] = script_option[3]
   --global.number[8] *= 60					-- redundancy. see invasion script. you change the enums so that they are in seconds not minutes.
   --game.round_timer = global.number[8]
   --game.round_timer = 1
   --if script_option[3] > 0 then
      game.round_timer = script_option[2]
   --end
   --global.timer[5] += game.loadout_cam_time
   --for each player do
      --script_widget[3].set_visibility(current_player, false)          -- doesn't work.
   --end

-- random loadout cameras removed for Flood
--- v2
   --for each object do
      --if current_object.is_of_type(initial_loadout_camera) then
	     --global.number[10] +=1 
		 --current_object.number[0] = global.number[10]
	  --end
   --end
   -- choose a random index
   --global.number[10] = rand(global.number[10])
   --global.number[10] += 1
   -- identify chosen camera
   --for each object do
      --if current_object.is_of_type(initial_loadout_camera) and current_object.number[0] == global.number[10] then
         --global.object[8] = current_object
		 -- move all other cameras to the chosen camera's location. deleting all others didn't work.
	     --for each object do
            --if current_object.is_of_type(initial_loadout_camera) and current_object != global.object[8] then
		      --current_object.copy_rotation_from(global.object[8], true)
			   --current_object.attach_to(global.object[8], 0,0,0,relative)
            --end
	     --end
      --end
   --end
end





-------- redundancy here: you can remove this function to save actions (at the cost of conditions).      probably good idea for flood.

-- combining res_zones() and kill_zones() functions into one to save space. They can only be combined in FFA games, where you can guarantee that all kill zones on the map will be neutral team. 
-- well that sucks. combining the two costs exactly the same number of conditions >:(
-- I suppose it saves actions but I haven't checked.
--function kill_res_zones()
   --global.number[10] = 0
   --if current_object.is_of_type(kill_boundary) or current_object.is_of_type(soft_kill_boundary) or current_object.is_of_type(safe_boundary) or current_object.is_of_type(soft_safe_boundary) then     -- or current_object.has_forge_label("inv_res_p1") or current_object.has_forge_label("inv_res_p2") or current_object.has_forge_label("inv_res_p3") or current_object.has_forge_label("inv_res_zone") then
      --global.number[10] = 1
   --end
--end


----- moved (to avoid repeated conditions).
-- One survivor fireteam. Allows respawning at front after betrayal.
--for each player do
   --if current_player.team == team[0] then
      --current_player.set_fireteam(0)
   --end
--end



--function infection_skull2()
--removed. 
--search in flood snippets.

---- Create AI skulls      -- no middleman resize or large offset.
function infection_skull()
   -- NOTE this can also trigger on "throw parasite" and swarm form thrall creation. 
   -- To exempt both these cases, add:                       and current_object.has_forge_label("parasite_res")
   -- To just exempt carrier form parasite throw, add:       "and global.number[10] != 1"
   --             Throw will create 27 at your position like a normal parasite_res, while thrall will actually enthrall them to the swarm form player (so it'll just be a double size swarm player at phase start).
   --             I'm keeping it for now coz who knows it might be cool, and it'll be rare anyway (most games alphas will be combat form, and also map ones will often activate in first 10 sec loadout cam time).
   if Parasite_Eruption_Round == 0 and global.number[10] != 1 then         -- and current_object.has_forge_label("parasite_res")
      global.number[10] = 28              -- 40 is too many. causes big lag spike on spawn, then deletes some map objects like grids (even objects the parasites aren't touching). Some spawn locations worse than others, I think if skulls to cramped together.
      Parasite_Eruption_Round = -1
      --send_incident(skullamanjaro, no_player, all_players)
      --for each player do
         --send_incident(skullamanjaro, current_player, all_players)
      --end
      --current_object.set_waypoint_visibility(everyone)
   end
   if global.number[10] > 0 then    --and global.number[10] < 19 then             -- 2nd condition is a failsafe, in case this is causing CGB lobby crashes. Probably redundant.
   global.number[10] -= 1
   --game.show_message_to(all_players, none, "inv_weapon")
   global.object[9] = global.object[2].place_at_me(skull, "p66", suppress_effect, 0,0,4, none)   -- resolved with suppress_effect --> has spawn glow. But I'm guessing the spawn offset is really gonna be worth it for random and natural placement.
   global.object[9].push_upward()
   --global.object[9].set_pickup_permissions(no_one)
   global.object[9].team = team[1]
   global.object[9].set_pickup_permissions(enemies)    -- RE-ADD v10          -- semi-redundant (flood only get pickup pulse on respawn, resurrect, eject)
   global.object[9].set_weapon_pickup_priority(automatic)         -- testing

   --global.object[9].object[0] = global.object[2].place_at_me(monitor, none, suppress_effect, 0,0,0, none)
   --global.object[9].object[0].attach_to(global.object[8], 0,0,0,relative)
   --global.object[9].object[0].max_shields = 0

   ------- Fusion coil hitbox. This is the best compromise imo. coil length aligned to skull length. +0.5 skull length in front and behind. perfect coverage EXCEPT small circle on crown.
   ------- if you want to remove circle crown non-coverage, increase coil scale to like 56 or 57. You might need to adjust attach distance tho (next line)
   ------- ---> Okay I've done that now. Full coverage now.
   --global.object[9].object[0] = global.object[2].place_at_me(fusion_coil, none, suppress_effect, 0,0,0, none)
   global.object[9].object[0] = global.object[2].place_between_me_and(global.object[2], fusion_coil, 0)
   global.object[8] = global.object[9].object[0].place_at_me(hill_marker, none, suppress_effect, 0,0,0, none)		-- troubleshooting      -- sniper_rifle   --sound_emitter_alarm_2
   --global.object[9].object[0].set_scale(56)
   --global.object[9].object[0].attach_to(global.object[8], -1,0,0,relative)         -- coil 55 scale, -87, 0,0, and middleman scale 2
   global.object[9].object[0].set_scale(80)
   global.object[9].object[0].attach_to(global.object[8], -2,0,0,relative)         -- coil 55 scale, -87, 0,0, and middleman scale 2
   global.object[8].copy_rotation_from(global.object[9], true)
   global.object[8].face_toward(global.object[8], 0,-1,0)         -- need to turn 90 degrees. I guess the skull is like covenant shield barrier: front is actually its temple. dumb lol.
   --global.object[8].set_scale(2)
   global.object[8].attach_to(global.object[9], 0,0,0,relative)
   
   global.object[9].object[0].max_health *= 10000
   global.object[9].object[0].health = 100
   --global.object[9].object[0].set_invincibility(1)		-- troubleshooting 
   global.object[9].player[0] = global.object[2].player[0]     -- parasite's daddy. For kill credit messages and score. luxury.
   
   global.object[9].number[0] = 100    -- long intial jump cooldown to stop middair apex jump. test if beneficial or not.     -- 60 too short.        -- 120 is long enough
   
   global.object[9].number[7] = 666

   -- thralls
   if global.object[2].number[7] == 33 or global.object[2].number[7] == juggernaut_ID and current_object == no_object then
      global.object[9].object[2] = global.object[2]      -- identify as thralls.
      --global.object[9].number[5] = 10      -- v7.7 remove. this is just to test throwable thralls
   end
   infection_skull()
   end
end





------ plan
-- label = spawner
-- spawn sequence = frequency. negative = double
-- team = phase. neutral = always
-- spawn seq 0 = disable

for each object with label "parasite_res" do
   if current_object.team == neutral_team or current_object.team == phase_team and current_object.spawn_sequence != 0 then     --and gLobal.number[2] == 69  -- and team[4].number[3] == 10   remove last condition (done). trailer test.
         current_object.number[5] = abs(current_object.spawn_sequence)
         --current_object.number[5] *= current_object.number[5]
         --current_object.number[5] /= current_object.spawn_sequence     -- absolute (make positive)    <-- wait this doens't work. dividng by -1 if negative spawn sequence.
         --if current_object.number[5] < 0  then
            --current_object.number[5] *= -1
         --end
         
         -- the hive chooses a random number between 0 and its max production time. the hive will produce 3 (or 6 if negative spawn seq) parasites when that wait has completed, then pick random again.
         -- the production time only resets once per count of max production time. So if max production time is 80 sec, it will only produce parasites once per 80 sec windowm, but at a random time
         --current_object.set_waypoint_text("%n/%n", hud_target_object.number[0], hud_target_object.number[4])
         --current_object.set_waypoint_visibility(everyone)
         
         -- redundancy here. could use %= to make counting more efficient.
         if current_object.number[0] == current_object.number[5] or current_object.number[4] == 0 then
            current_object.number[4] = rand(current_object.number[5])
            current_object.number[0] = -1
         end
         --if current_object.number[4] == 0 then
            --current_object.number[4] = rand(current_object.number[5])
         --end 
         -- once per sec
         if global.number[6] == 60 then
            current_object.number[0] += 1
            if current_object.number[0] == current_object.number[4] then
               --current_object.number[4] = 0
               --current_object.number[0] = -1
               global.object[2] = current_object
               global.number[10] = 3
               infection_skull()
               if current_object.spawn_sequence < 0 then
                  global.number[10] = 3
                  infection_skull()
               end
            end
         end
   end
end



--for each object with label "inv_res_zone" do
   --if current_object.spawn_sequence <= global.number[2] then 
      --Auto11A0454B_291()
      -- auto generated by RVTOOL
      -- auto generated by RVTOOL
      -- auto generated by RVTOOL
   --end
--end

---- my streamlining of inv_res code using functions.
-- if you decided to remove separate fireteam zones alltogether then this would get even shorter. The repeated middle lines would go.
--function inv_res_pX()
   --current_object.set_spawn_location_permissions(no_one)
   --if global.number[2] == global.number[10] then
      --Auto11A0454B_291()
-- auto generated by RVTOOL
      -- auto generated by RVTOOL
      -- auto generated by RVTOOL
      -- Parasite hive = yellow team
      --if current_object.team == team[5] then
         --current_object.number[5] = current_object.spawn_sequence
         --current_object.number[5] *= current_object.number[5]
         --current_object.number[5] /= current_object.spawn_sequence
         -- the hive chooses a random number between 0 and its max production time. the hive will produce 3 (or 6 if negative spawn seq) parasites when that wait has completed, then pick random again.
         -- the production time only resets once per count of max production time. So if max production time is 80 sec, it will only produce parasites once per 80 sec windowm, but at a random time
         --if current_object.number[0] == current_object.number[5] then
            --current_object.number[4] = 0
            --current_object.number[0] = -1
         --end
         --if current_object.number[4] == 0 then
            --current_object.number[4] = rand(current_object.number[5])
         --end 
         -- once per sec
         --if global.number[6] == 60 then
            --current_object.number[0] += 1
            --if current_object.number[0] == current_object.number[4] then
               --global.object[2] = current_object
               --global.number[10] = 3
               --infection_skull()
               --if current_object.spawn_sequence < 0 then
                  --global.number[10] = 3
                  --infection_skull()
               --end
            --end
         --end
      --end
   --end
--end

--for each object with label "inv_res_p1" do
   --global.number[10] = 1
   --inv_res_pX()
--end

--for each object with label "inv_res_p2" do
   --global.number[10] = 2
   --inv_res_pX()
--end

--for each object with label "inv_res_p3" do
   --global.number[10] = 3
   --if global.number[2] > 3 then			-- luxury feature. semi-redundant. added to prevent end-of-round out of map respawns. forgers can use inv_res_zones for phase 3 otherwise to avoid it.
      --global.number[10] = global.number[2]
   --end
   --inv_res_pX()
--end
------------------------------ end of spawning




--------- Team assignment (script_option[1] removed from script, elites are now hard-wired infected :)
-- team[0] are spartans
-- team[1] are elites
-- global.team[0] defends the objective
-- global.team[1] attacks the objective
-- team[0] are the survivors
-- team[1] are the infected

--do
   host_indicator = 1
   team[0].number[3] = 0      -- number of survivors
   --global.number[0] = 0     -- sudden death removed v11
   --if script_option[3] > 0 then
   game.round_timer.set_rate(-100%)
   --game.round_timer = 1    -- stest
   --end
   --global.timer[2].set_rate(-100%)
   --global.timer[3].set_rate(-100%)           -- host_existance_check.
   --host_existance_check.set_rate(-50%)         --  20 seconds for CGB kill version to give host enough time to get outta pelican.
   --global.timer[5].set_rate(-100%)				-- in invasion, this is global.timer[7].set_rate(-100%) too.
   --global.team[1] = team[0]
   --global.team[0] = team[1]
   
   -- script option removed, so this has been moved to declarations.
   --if script_option[1] > 0 then 				-- in invasion, "> 0" because I changeed the enums to -1 and 1 for script cheapness reasons.
      --global.team[1] = team[1]
      --global.team[0] = team[0]
   --end
   --global.team[3] = team[0]						-- two redundant lines. In Win Con, the infected team is always the elites (team[1]) and the survivors always spartans (team[0]). You can replace all instances in script.
   --global.team[4] = team[1]
--end

--do
--   team[0] = team[1]
--   team[1] = team[0]
--end


------------------------------------------- end of init: set up, 	begining of infection script.

-------- 3 growing bomb node version
function corpse_blobs()
            global.object[2].number[7] = 110
            global.object[3] = global.object[2].place_between_me_and(global.object[2], skull, 0)

            global.object[8] = global.object[2].place_at_me(skull, none, suppress_effect, 3, 0, 0, none)
            global.object[8].face_toward(global.object[3], 0,0,0)
            global.object[8].attach_to(global.object[2], 0, 0, 4, relative)

            global.object[8] = global.object[2].place_between_me_and(global.object[3], skull, 0)
            global.object[8].attach_to(global.object[2], 0, 0, 6, relative)
            global.object[8] = global.object[8].place_at_me(skull, none, suppress_effect, 3, 0, 0, none)
            global.object[8].attach_to(global.object[2], 0, 0, 6, relative)
            
            global.object[8] = global.object[2].place_at_me(skull, none, suppress_effect, -3, 0, 0, none)
            global.object[8].face_toward(global.object[2], 0,0,0)             -- for infection skull to face good when attached.
            global.object[8].attach_to(global.object[2], -1, 0, 5, relative)
            --global.object[2].object[0] = global.object[8]                     -- this nesting is needed for skull to attach to if survivor dies.     -- I think redundant v23         --global.object[3].object[0] = global.object[8]
            --global.object[3].attach_to(global.object[2].object[0], 0,0,0,relative)
            global.object[3].attach_to(global.object[8], 0,0,0,relative)
            --global.object[3].number[6] = -200         -- make the parasite wait 3 seconds before resizing          -- I reckon this is redundant now v23
end


-- CrudeOwl's Entry Point script removed.

-- mark players who have just become infected last tick with number[5] == 1
--for each player do
   --if current_player.team == team[1] then
      --if current_player.number[5] < 2 then 
         --current_player.number[5] += 1
      --end
   --end
--end

-- REMOVE. trailer.
--for each object do
   --if current_object.is_of_type(ghost) and current_object.object[0] == no_object then
      --current_object.object[0] = current_object.place_at_me(spartan,none,none,127,0,0,none)     -- NPC testing
      --current_object.attach_to(global.object[4], 0,0,0,relative)
      --current_object.object[0].max_shields = 0
   --end
--end

------- phase testing     skip phases
--for each object with label "flood_obj" do
   --if current_object.team == team[0] or current_object.team[0] == team[1]  then   
      --current_object.delete()
   --end
--end



-- New Entry Point waypoint
------ v17 re-add



-- NPC corpses (NPCs).     -- cheap version
-- re-add v17
--for each object with label "flood_victim" do


--NPC killing by parasites.       -- luxury
-- removed


-- Find master hill marker                         -- luxury? Not sure but Belly of the Beast might require one.
-- v17 re-add
--for each object with label "create" do
   --if current_object.spawn_sequence == 0 then
      --global.object[4] = current_object					
   --end
--end

-- If no master hill marker, then create a master hill marker control box
--if global.object[4] == no_object then
for each object do
   if global.object[4] == no_object then
      global.object[4] = current_object.place_at_me(hill_marker, none, none, -127,127,-127, none)		-- make master hill marker hidden underground
      -- stest swarm
      --for each object with label "flood_obj" do
         --global.object[8] = current_object.place_at_me(spartan, none,none,0,0,0,none)  
      --end
		 --global.object[4].set_waypoint_visibility(everyone)			-- troubleshooting
         -- cover it with a pelican. It's a shot-in-the-dark attempt to block teleporter recievers so this doesn't break maps which don't have a placed master hill marker but do have inv_vehicle tele systems.
		 --global.object[14] = global.object[4].place_at_me(pelican_scenery, none, none, 0,0,0, none)			-- no longer needed now that it spawns underground!
   end
end
--end


---- Flashlights guide
-- 1. To set up a map to ALWAYS have flashlights, place a purple FX with label "Flashlights"
-- 2. For other maps, label anything you want to delete when midnight mode (flashlights) are activated by gametype with "Flashlights" and it'll get deleted. 
-- E.g. the label juicy FX on 343 Milky Spark. I generally recommend labelling all other FX "Flashlights" because it's usually too hard for Flood to see if there are additional FX on top of purple.

-------- Action efficient version.  -2 conditions, +1 action
-- flashlights enabled gametype option.         
for each object with label "Flashlights" do
   if global.object[4].object[0] != current_object and global.object[4].object[0] != no_object then           -- script_option[10] == 1 or script_option[10] == game.current_round and
      current_object.delete()
   end
   --global.object[4].object[0] = global.object[4].place_at_me(fx_purple, "Flashlights", none, 0,0,0, none)       -- moved to separate block.      - 3 conditions, + 1 action
end
if script_option[10] == 1 or script_option[10] == game.current_round and global.object[4].object[0] == no_object then
   global.object[4].object[0] = global.object[4].place_at_me(fx_purple, "Flashlights", none, 0,0,0, none)
end



--Midnight_Mode
--midnight_del
--Flashlights


-- create master hill master delegate (global[14])          -- luxury?
--if global.object[14] == no_object then
   --global.object[14] = global.object[4].place_at_me(hill_marker, none, none, 0,0,0, none)
--end

--do



   --if script_option[1] == 55 then
      --global.object[4].number[0] = 1
   --end
  -- global.object[4].set_waypoint_text("%n percent infected", global.object[4].number[2])		-- remove when done troubleshooting
  -- global.object[4].set_waypoint_visibility(everyone)											-- remove when finished troubleshooting
   
   -- tick alternater
   --if global.object[4].number[4] == 0 then
      --global.object[4].number[4] = -1
   --end
   --global.object[4].number[4] *= -1
   
   -- 60 tick counter
   --if global.object[4].number[4] == 60 then
      --global.object[4].number[4] = 0
   --end
   --global.object[4].number[4] += 1
 --end



-------------------------------- No Red Names.
-------- Better version
-- WARNING: map placed purple with "flashlights" label makes it flashlights every round BUT will fail to remove flood red names. Add the extra two lines above to make 
--for each object with label "Flashlights" do
   --if current_object.is_of_type(fx_purple) then
      --for each player do
      -- Flood have no red name when flashlights mode is on
         --if current_player.number[1] == 1 then
            --current_player.apply_traits(script_traits[11])
         --end
      --end
   --end
--end
-------- Cheap version. Use the above version to make no red names work on flashlight-only maps!
-- action efficient. Separated from the following bloock for +1 action cheaper but -1 condition and -1 trigger.
for each player do
-- Flood have no red name when flashlights mode is on
   if current_player.number[1] == 1 and global.object[4].object[0] != no_object then
      current_player.apply_traits(script_traits[11])
   end
end




--------- v10
------ late joiner zombification (fully here, unlike in modded ghostbusters where it's split into 2 parts)
for each player do
   --global.object[4].timer[2].set_rate(-25%)											-- 40 second grace period
   --global.object[4].timer[3].set_rate(-100%)	-- 30 second grace period. 		changed to use a 100% timer to limit the amount of time that scaled obejct have quicksand physics at round start.
   if current_player.team != team[0] and global_tick_counter >= 1800 then     -- and global.object[4].timer[3].is_zero() then
      current_player.number[1] = 1
--                                           -- late joiner lacks mark for initial spawn point killing exemption.
   end
end
for each player do
   --if not global.object[4].timer[3].is_zero() then		-- this if criteria added by me. hopefully will hard-prevent late joiners being survivors.
   if global_tick_counter < 1800 then
      current_player.team = team[0]
	   current_player.number[3] = 2           -- mark as present at start, exempt from initial spawn point killing.
   end
end
for each player do
   if current_player.number[1] == 1 then 
      current_player.team = team[1]
	   current_player.apply_traits(script_traits[3])			-- infected base traits applied here. includes 100% resistance, since base players have 110% resistance in this gametype.
      -- Flood have no red name when flashlights mode is on
      --if global.object[4].object[0] != no_object then
         --current_player.apply_traits(script_traits[11])
      --end
      -- low damage for dead flood players to stop full damage sword death trading.          -- moved further down.
      --if current_player.biped == no_object then
         --current_player.apply_traits(script_traits[8])
      --end
      --if current_player.number[3] == 1 then 
         --current_player.apply_traits(script_traits[1])		-- alpha traits here. not intended to be different at all, since I have a loadout traits system with P1 power classes instead.
      --end
   end
end

-- initial spawn point killing.			-- should also prevent the weird bug which changes elite armour colour to player customization preference visor colour. Might also prevent the allied red reticle bug.
for each player do
   if current_player.number[3] == 0 and current_player.biped != no_object then
      current_player.biped.kill(false)
	   current_player.number[3] = 2		-- mark as finished initial_spawn_point killing
   end
end   

-- removed for space now unlimited scale scripted objects. ALSO saving object count on Kye's map coz I'm now using a blue initial spawn point as a labelled inv respawn zone.
---- intitial spawn point deletion (for freeing up scripted objects). brown team exempted (this is a scripted audio cue). 			
--for each object do
   --if current_object.is_of_type(initial_spawn_point) and global.object[4].timer[3].is_zero() and not current_object.team == team[6] then
      --current_object.delete()
   --end
--end


------ Last man MOVED.


--team[0].number[3] += 1        -- swarm size singleplayer testing
--team[0].number[3] = 10        -- swarm size singleplayer testing


----- Last man standing traits removed.
--for each player do
--   if current_player.number[2] == 1 then 
--      current_player.apply_traits(script_traits[2])
--   end
--end


-- elite testing     -- elite starts
--for each player do
   --current_player.number[1] = 1
--end


------------------ New dynamic scaling: alpha zombies not treated any differently.
----- dynamic scaling inflammation
-- NOTE this section must come AFTER the above section which applies infected traits, because this section's 90% resistance traits need to override the infected traits's 100% resistance.
--do
   --global.number[10] = 0
   --global.number[11] = -1				-- original script does this, I think to prevent converting first player in a lobby to an alpha zombie. I'm instead subtracting 1 further down.

-- shared do block. Somtimes saves space I think? not totally sure.
do
   global.number[11] = 0			                     -- total player count
   global.object[4].number[1] = 0	                  -- total number of all infected
   --global.object[4].number[0] = script_option[1]	   -- alpha zombie count. gets changed in next section if scaling option is selected.
   global.object[4].number[4] = 0                     -- power class count
   global_tick_counter +=1                            -- game start announcements
end

----- Count living power classses (NOT swarm forms)         -- luxury for flood
for each player do
   global.object[2] = current_player.biped
   if global.object[2].number[1] == 3 then         -- global.object[2].number[1] of 3 is the mark of any power class.
	  --if global.object[2].number[0] >= 11 then
	   global.object[4].number[4] += 1
	  --end
   end
end
   
for each player do
   --current_player.set_round_card_title("This mod took over 400 hours to create \r\nPlease consider donating!    :) \nko-fi.com/RabidMagicMan")
   current_player.set_round_card_title("This mod took over 600 hours to create \nDonate so I can keep updating it!    :) \nko-fi.com/RabidMagicMan")
   current_player.biped.set_waypoint_priority(low)		-- normal
   global.number[11] += 1										-- global.number[11] is the total number of players
   --if current_player.number[3] == 1 then 
      --global.number[10] += 1										-- global.number[10] is the number of alpha zombie players
   --end
   if current_player.team == team[1] then
      current_player.team[0] = team[2]      -- green team = prohibited vehicles
      current_player.set_loadout_palette(elite_tier_1)
      global.object[4].number[1] += 1								-- global.object[4].number[1] is the total number of all infected
      global.object[6] = current_player.try_get_weapon(primary)      -- luxury. rocket flood don't get debuff so they always have 90% damage (81% actual) to make them more deadly as bosses.
      if global.object[4].number[2] >= 55 and not global.object[6].is_of_type(rocket_launcher) then
         current_player.apply_traits(script_traits[2])			-- when more than 55% infected, give all zombies 90% resistance.		new debuffs: 90% damage, finite ammo.
      end

   end
   if current_player.team != team[1] then
      current_player.team[0] = team[4]      -- purple team = prohibited vehicles
      current_player.set_loadout_palette(spartan_tier_1)		-- spartans only ever use tier 1 loadouts
      --current_player.set_fireteam(0)		-- one shared fireteam.       -- pretty sure you can do this in gametype options.
      if global.object[4].number[2] >= 67 then
         current_player.apply_traits(script_traits[1])				-- when more than 67% infected, give all survivors 110% damage			new buffs: 150% shield regen, 200% health regen, infinite ammo
         if global.object[4].number[2] >= 80 then
            current_player.apply_traits(script_traits[0])				-- when more than 80% infected, give all survivors 125% damage			new buffs: 200% shield regen
         end
      end
   end
   -- low damage for dead flood players to stop full damage sword death trading.
   if current_player.biped == no_object and global_tick_counter > 1805 or current_player.object[0] != no_object then
      current_player.number[6] += 1       -- Dead tick counter. Used for choosing flood players to resurrect.
      --current_player.apply_traits(script_traits[8])      -- 50% traits (25% actual)
      current_player.apply_traits(script_traits[14])       -- 0% damage.  Changed so that it also stops target locator murder-suicide trolling.
      -- auto-infect normal players who have a corpse (not late joiners during grace period), and monitor players who have died after loadout time.
      if current_player.number[6] == 10 and current_player.object[0] != no_object or current_player.number[1] == -3 then 
         current_player.number[1] = 1
      end
   end
end

global.object[4].number[2] = global.object[4].number[1]
global.object[4].number[2] *= 100			-- multiply to create a percentage and to avoid rounding errors
-- the /= operator discards the remainder. Which you can think of as rounding the decimal DOWN.
global.object[4].number[2] /= global.number[11]			-- global.object[4].number[2] is the percentage of infected players. 2 significant figures, rounded down.
-- I've hardwired to change alpha zombie count to 2 when lobby has more than 6 players, if script option is 55 (my added). 
-- This is because most of the proportional balancing is from loadout tiers.
-- Also, only happens if not more than 30% of players have been infected. i.e. it won't create a new alpha zombie if a bunch of people join late and push it over the 7 player threshold.
--if global.number[11] > 6 and script_option[1] == 1 and global.object[4].number[2] < 25 then			-- script_option[1] == 55           changed back now I have 1 power class tranisitionary period --> changed to >6 to >7 players now that power class cut off has been lowered from 30% to 25%
   --global.object[4].number[0] = 2
--end 

-- Flood scaling 20% alpha count.       Aim:  4 or fewer players = 0 alphas     9 or fewer players = 1 alphas     14 or fewer players = 2 alphas         15 or 16 players = 3 alphas
--lobal.number[11] = 16           -- testing thresholds
--if script_option[1] == 58 then
   --global.object[4].number[0] = global.number[11]
   --global.object[4].number[0] /= 5
   --game.show_message_to(all_players, none, "%n", global.object[4].number[0])     -- testing thresholds
--end 

-- Proportional alpha zombies script options
if script_option[1] >= 5 then        -- v14 removed for space. it only works as proportional now.        -- nvm, it doesn't save an action to remove this so I ought to keep it.
   global.object[4].number[0] = global.number[11]
   global.object[4].number[0] /= script_option[1]
   --game.show_message_to(all_players, none, "%n", global.object[4].number[0])     -- testing thresholds
end 


--if global.number[10] > 6 and script_option[1] == 55 and global.object[4].number[2] < 25 then			-- changed back now I have 1 power class tranisitionary period --> changed to >6 to >7 players now that power class cut off has been lowered from 30% to 25%
   --global.object[4].number[0] = 2
--end 


--global.number[11] -= 1			-- added to prevent single player lobby becoming an alpha zombie.		-- testing redundant
for each player randomly do
   if global.object[4].number[1] < global.object[4].number[0] and current_player.number[2] != 1 and current_player.number[1] != 1 then 				-- and global.object[4].number[1] < global.number[11]
      current_player.number[1] = 1
      --current_player.timer[3] = 3
      global.object[4].number[1] += 1
      --current_player.number[3] = 1				-- alpha zombie ID no longer used: redundant
   end
end
for each player do
   if current_player.number[1] == 1 and current_player.team != team[1] then 
      send_incident(inf_new_zombie, current_player, no_player)
      current_player.team = team[1]
      --current_player.apply_traits(script_traits[0])
      current_player.biped.kill(true)
   end
end
--end


-- elite testing. power class testing.
--global.object[4].number[2] = 10           -- 10% infected override.
--global.object[4].number[2] = 80



function parasite_corpse_infection()
-- be warned 5 isn't far enough to always auto-infect with players punching an enemy biped.
      --global.object[8] = global.object[2].place_between_me_and(global.object[2],light_green, 0)    -- troubleshooting
      --global.object[8] = global.object[3].place_between_me_and(global.object[3],light_red, 0)      -- troubleshooting
      current_object.delete()
      global.player[6].biped.delete()        -- auto-possess awakened_parasite.
      --current_object.object[2].delete()      -- Swarm Form possess, delete thrall's owner biped. WARNING if in a function with awakend parasite, that parasite's biped.object[2] is local red reticle target.
      global.player[6].set_biped(global.object[2])       -- troubleshooting, removed
      send_incident(infection_10x, global.player[6], global.player[6]) 
      global.object[2].player[1] = global.player[6]
      if global.object[2].number[7] == 0 then       -- to prevent double corpse blobs from auto-possess awakened parasite.
         corpse_blobs()
      end
   --end
end


function new_infection_incidents()
   -- I've set it up this way because parasites never get kill credit. If anything else harmed the player shortly before parasite kils them, they'll already be infected by this point in script.   
   -- this condition is to stop parasite infection from firing two all_player kill feed messages about who infected a target, if the parasite assisted while the target was killed directly by a
   -- flood player.
   if current_player.number[1] != 1 then
      send_incident(inf_new_infection, global.player[6], current_player)
   end
   -- copied from get_killer, then added a con. could be a function for space. 
   current_player.number[1] = 1
   send_incident(infection_kill, global.player[6], current_player)
   global.player[6].score += 1
   --if current_player.player[1] != no_player then
   game.show_message_to(current_player.player[1], none, "One of your parasites infected a host!")
   --end
   --global.player[6].script_stat[3] += 1
end



------------------------ infection killer player incidents
for each player do
   if current_player.killer_type_is(guardians | suicide | kill | betrayal | quit) then 
      --game.show_message_to(current_player, none, "inv_vehicle")
      --current_player.number[2] = 0         -- end last man standing. testing redundant v34.
      --global.player[7] = current_player
      --global.player[6] = no_player            -- testing redudant
      global.number[10] = current_player.try_get_death_damage_mod()
      global.player[6] = current_player.try_get_killer()
      global.object[3] = global.player[6].biped       -- killer biped
      global.object[2] = current_player.object[0]     -- dead biped
      
	  -- my addded. assist points same as kill points, because this plays like a team game imo. Also in Reach you need to to 40+% damage to get an assist.
	  -- needs to be above the other score parts in this loop because this checks team through the player.number[1] (proxy for team), a template I'm copying from these other parts here, and those
	  -- parts can CHANGE the killed player's number[1] if the killed player gets infected.
-- removed for space, because assisted_kill_of doesn't seem to do anything at all sadly (and no other modders have ever tried to use it).   
	  --for each player do
         --if current_player != global.player[7] and current_player.assisted_kill_of(global.player[7]) and current_player.number[1] != global.player[7].number[1] then
            --current_player.score += 1
         --end
	  --end
	  
	  -- end of my added.
      if current_player.killer_type_is(kill) and current_player.number[1] == 1 then 		-- and current_player.number[1] != global.player[6].number[1] then 
         global.player[6].score += 1
         send_incident(zombie_kill_kill, global.player[6], current_player)
         --current_player.number[4] += 1
      end
      if current_player.killer_type_is(kill) and global.player[6] != no_player and current_player.number[1] <= 0 then        -- the global.player[6] line might be redundant.
         --current_player.timer[3] = 3
         new_infection_incidents()
         --current_player.number[1] = 1
         --send_incident(inf_new_infection, global.player[6], current_player)
         --send_incident(infection_kill, global.player[6], current_player)
         --global.player[6].score += 1
         --global.player[6].script_stat[3] += 1
         
         -- Awakened Parasite auto-possess
         -- the 2nd condition is MAYBE redundant. In theory, this is the first thing which will be able to infect a corpse, so the corpse's resurrecting player shouldn't already be filled. failsafe condition.
         -- assassination condition probably redundant condition.
         -- final condition is for monitor.
         if global.object[3].number[7] == 26 and global.object[2].player[1] == no_player and global.number[10] == enums.damage_reporting_modifier.pummel and global.object[2].is_of_type(spartan) then        -- or global.number[10] == enums.damage_reporting_modifier.assassination
            parasite_corpse_infection()
            -- create new corpse blobs if not already.
            --if global.object[2].number[7] != 110 then
               --corpse_blobs()
            --end
         end
      end
      -- I think this is redundant now I've added the broader auto-infect to dead player things.
      --if current_player.killer_type_is(suicide) or current_player.killer_type_is(guardians) then 
         --global.player[6].score += -1
         --current_player.number[1] = 1
         -- okay that's pretty weird. even when it says "killed by guardians" it's not actially triggering this. Same if I put the killfeed message at the top of this block. seems script killing guardians doesn'table.concat
         -- count as guardians killer type. at least not when i'm testing with monitor being chewed by parasites.
         --game.show_message_to(current_player, none, "inv_vehicle")       
      --end
	  -- semi-redundant. conditions removed for space.
	  -- This stops -1 points for betrayal when you've just been infected and get bretrayals from the grave (e.g. sticking someone as they kill you), by giving a 3 second grace period.
	  -- My gametype has friendly fire off, so this is basiccally impossible anyway. I'm gonna go ahead and remove the conditions
      --if current_player.killer_type_is(betrayal) and global.player[6].timer[3].is_zero() and current_player.timer[3].is_zero() and current_player.number[1] == global.player[6].number[1] then 
      if current_player.killer_type_is(betrayal) then
		   global.player[6].score -= 1       -- ITALIAN RE-ADD
         current_player.number[6] = -2000     -- immunity to auto-infection (and being placed in writhing corpses too)
      end
   end
end



-------- COUNT SURVIVORS -------
   --team[0].number[3] = 0       -- moved to "timer do loop" to save 1 trigger.  <-- didn't save an action, sad times.
   for each player do
      --if not current_player.number[1] == 1 then
      if current_player.number[1] == 0 then     -- excludes monitors
         team[0].number[3] += 1
         global.player[4] = current_player
      end
   end
   if team[0].number[3] == 1 and global.player[4].number[2] != 1 then 
      global.player[4].number[2] = 1
      --global.player[4].score += 1             -- semi-redundant
      send_incident(inf_last_man, global.player[4], all_players)
   end
	-- if no survivors left, give 0 points to all infected players except the player who was just last man standing (dumb af), then end the round.
   if team[0].number[3] == 0 or game.round_timer.is_zero() then 
      --send_incident(infection_zombie_win, all_players, all_players)         -- elite testing
      --game.end_round()		-- elite testing
   end
--------------------------------

team[0].number[3] = 10     -- elite testing: behave as though 10 survivors remaining.



--- okay CRACKED IT pretty sure all this does is make ONE LIFE games work.
-- Pretty sure this is just counting infected players who haven't been killed at least once and don't have 
--- any current biped and then triggering the end of the game if there are none. Can't explain that better but yeah. I think this is only relevant for 1 life games.
--- which makes sense because infection is the only gametype which automatically ends when one team has no players left alive. 
--- I added this ability to Spartan 6 Siege and actailly I did a similar script mechanism. it like counted number of time when a team has no players with a current_biped, and 
--- ended the game if it went on for long enough. this does the same with a timer.


--if team[1].has_any_players() then 
   --if team[1].number[5] == -77 then 
      --global.timer[4].reset()
   --end
   --team[1].number[3] = 0         -- count infected players.       redundancy. I already count players for dynamic scaling, right?
   --team[1].number[5] = 0
   -- I'm not sure what this here is, but pretty sure it's checks to prevent round end timers. I suspect they're pointless though.
   -- okay yeah i honestly can't tell wtf this is doing, if anything. the only time player.number[4] is used is to count each time a zombie dies...? wtf why? Seems totally weird and pointless to me.
   
   --for each player do
      --if current_player.number[1] == 1 then 
         --team[1].number[3] += 1
         --global.player[7] = current_player
         --for each player do
            --if not global.player[7] == current_player and current_player.number[1] == 1 and global.player[7].number[4] != current_player.number[4] then 
               --team[1].number[5] = -77
            --end
         --end
         --if current_player.biped != no_object or current_player.number[4] < 1 then 
            --team[1].number[5] = -77
         --end
      --end
   --end
   --if team[1].number[5] != -77 and team[1].number[3] > 0 then 
      --global.timer[4].set_rate(-50%)
      --if team[1].number[3] < 4 then 
         --global.timer[4].set_rate(-25%)
      --end
      --if global.timer[4].is_zero() then 
         --team[1].number[5] = -343
      --end
   --end
--end


-- Monitor spawn chance
--global.number[8] = rand(1)    -- v14 re-add

----- Game start announcements v11.       + 9 conditions    + 3 actions
-- re-add v17




------- plan
-- if less than 33% infected, at least 1 power class should be allowed





----- Max allowed power classes on respawn. Used for calculation and for widget.
--global.object[14].number[6] = 0
-- if less than 33% infected, set maximum to 1
--if global.object[4].number[2] <= 33 then
   --global.object[14].number[6] = 1
--end
-- if power classes all available, then simply set the max to the number of infected players
--if global.object[4].number[2] < 25 then
   --global.object[14].number[6] = global.object[4].number[1]
--end

--for each player do
   --if current_player.is_elite() and current_player.biped == no_object then
     --script_widget[2].set_text( "Zealots & Ultras %n/%n", global.object[4].number[4], global.object[14].number[6])
     --script_widget[2].set_visibility(current_player, true)
   --end
--end





------ loadouts tiers v2
-- moved all the info from this to the proportion calculating block.


--for each player do
   --current_player.set_round_card_title("Mods by Rabid MagicMan \r\nJoin our Server!     rabid.tiny.us/discord \r\nWant more?        ko-fi.com/RabidMagicMan")
   --current_player.set_round_card_title("This mod took 100s of hours to create \r\nPlease consider donating! \r\nko-fi.com/RabidMagicMan")
   --current_player.set_round_card_title("This mod took over 400 hours to create \r\nPlease consider donating!    :) \r\nko-fi.com/RabidMagicMan")
--end





-------- power class testing			-- elite testing
--for each player do
    --current_player.biped.set_waypoint_visibility(allies)
    --current_player.biped.set_waypoint_priority(normal)
    --current_player.set_loadout_palette(spartan_tier_3)	
--end



------ Condition efficient version
-------- v1b
--for each player do
   --if current_player.team == global.team[0] then 
      --current_player.set_round_card_title("DEFEND THE OBJECTIVE")
	  --current_player.set_round_card_title("Mods by Rabid MagicMan \r\nDiscord server: https://discord.gg/HPq7bDHF")
   --end
--end

--for each player do
   --if current_player.team == global.team[1] then 
	  --current_player.set_round_card_title("Mods by Rabid MagicMan \r\nServer:      rabid.tiny.us/discord")
   --end
--end



--global.number[10] = global.number[3]
--global.number[10] %= 2
--for each player do
   --if current_player.team == global.team[1] then 
      -- if core or territories
      -- if global.number[3] == 3 or global.number[3] == 1 then 
      --if global.number[10] == 0 then 
         --current_player.set_round_card_title("CAPTURE THE OBJECTIVE")
      --end
      -- if assault or generators
      -- if global.number[3] == 4 or global.number[3] == 2 then 
      --if global.number[10] != 0 then 
         --current_player.set_round_card_title("DESTROY THE OBJECTIVE")
      --end
   --end
--end

--function hide_teleporter()
   --if current_object.team == team[5] and current_object.object[1] == no_object then
		--current_object.object[1] = current_object.place_between_me_and(current_object, hill_marker, 0)
		--current_object.attach_to(current_object.object[1], 0, 0, 0, relative)
	--end
--end

--- explode scripted bomb
for each object do
   if current_object.number[7] == 6666 then
      current_object.kill(false)
   end
end

--- hide scripted bomb objects.        luxury. If you do this with hide_action on local, you would save an action. BUT then forgers will see the balls while singleplayer testing and probably try to hide them manually.
for each object do
   if current_object.team == team[6] and current_object.is_of_type(soccer_ball) or current_object.is_of_type(golf_ball) then      --  and not current_object.shape_contains(current_object)
	   --global.object[8] = current_object.place_between_me_and(current_object, hill_marker, 0)
	   --current_object.attach_to(global.object[8], 0,0,0,relative)
      --global.object[8].team = team[6]     -- so the hill marker also gets deleted
      current_object.set_scale(1)      -- cheaper hiding.
      current_object.copy_rotation_from(current_object, false)       -- compulsory, for some reason, even on host
      --current_object.set_shape(cylinder, 30, 30, 30)
   end
end


---- inv_vehicle
for each object with label "inv_vehicle" do
   if current_object.spawn_sequence > global.number[2] then 
      -- non-respawnable objects leave a marker, and get treated differently (they don't get deleted later). Also, Orange team vehicles will spawn instantly, even if "never" respawn. Orange team.
      --kill_res_zones()
	   --if current_object.object[0] == no_object and current_object.team == team[3] or current_object.is_of_type(pelican_scenery) or global.number[10] == 1 then 	-- or current_object.is_of_type(hill_marker) then 
      if current_object.object[0] == no_object and current_object.team == team[3] or current_object.is_of_type(pelican_scenery) or current_object.is_of_type(kill_boundary) or current_object.is_of_type(soft_kill_boundary) or current_object.is_of_type(safe_boundary) or current_object.is_of_type(soft_safe_boundary) then
         current_object.object[0] = current_object.place_between_me_and(current_object, hill_marker, 0)
      end
	   --current_object.attach_to(global.object[4], 0, 0, 0, relative)      -- condition efficient version
   end
end
for each object with label "inv_vehicle" do
   if current_object.spawn_sequence > global.number[2] then 
	   current_object.attach_to(global.object[4], 0, 0, 0, relative)        -- +1 action, -1 condition here.
   end
end
-- visible shapes! 
for each object with label "inv_vehicle" do
   if current_object.spawn_sequence <= global.number[2] then 
	   if current_object.is_of_type(hill_marker) then                       -- +1 action, -1 condition here.
         current_object.set_shape_visibility(everyone)
	   end
   end
end
-- Non-respawnables.
for each object with label "inv_vehicle" do
   if current_object.spawn_sequence <= global.number[2] then
      if current_object.object[0] != no_object or current_object.team == team[6] then
         current_object.number[1] += 1
         if current_object.number[1] == 5 then          --    <= 10 swap with this an add lower condition is locations don't sync or you get black screens.         -- old comment: this has to be higher than 10, or causes black screen. 500 works.
            current_object.attach_to(current_object.object[0], 0,0,0,relative)
            --if current_object.number[1] == 10 then			-- 60 worked
               current_object.detach()
               current_object.object[0].delete()
            --end
         end
      end
   end
end

for each object with label "inv_vehicle" do
   -- when relevant phase begins, unrespawnables.
   if current_object.spawn_sequence <= global.number[2] then
	   -- visible shapes! 
	   --if current_object.is_of_type(hill_marker) then --and current_object.team != team[6] then		-- removed for space
         --current_object.set_shape_visibility(everyone)
	   --end
	  -- delayed inv_gates
	  -- delete any brown team objects in this shape. Can be used for delayed inv_gates, mass inv_gates, and inv_gates for objects from other labels too!
	  -- warning: could cause overloading with quickly respawning delete targets with labels, because some (inv_obj, inv_vehicle, maybe others) place object.objects which this doesn't delete.
	   if current_object.team == team[6] and current_object.number[1] > 5 then		-- tick count at least 2+ to give it time to be deleted from master hill marker below first.
	      global.object[3] = current_object
		  -- destroyable switch objects
		   global.number[10] = current_object.health
		   if global.number[10] > 0 then
		      current_object.number[2] = -1
	      end
		   if current_object.number[2] == -1 and global.number[10] == 0 then
		      current_object.number[2] = -2
		   end
		   if current_object.number[2] != -2 then
		   -- end of destroyable switch object checks
	         for each object do
			      --kill_res_zones()
		      --if global.object[3].shape_contains(current_object) and current_object.team == team[6] and current_object != global.object[3] then		--current_object.spawn_sequence <= global.number[2]
			   -- delete brown team objects, OR safe & kill zones. exempt safe and kill zones by setting them to "scale" label. Also now deletes any invasion respawn zones in brown controller zones.
		         --if global.object[3].shape_contains(current_object) and current_object != global.object[3] and current_object.team == team[6] or global.number[10] == 1 and not current_object.has_forge_label("inv_weapon") then-- removed conditions for space: 
                  
               if global.object[3].shape_contains(current_object) and current_object != global.object[3] and current_object.team == team[6] or current_object.is_of_type(kill_boundary) or current_object.is_of_type(soft_kill_boundary) or current_object.is_of_type(safe_boundary) or current_object.is_of_type(soft_safe_boundary) and not current_object.has_forge_label("inv_weapon") and not current_object.is_of_type(warthog) then    -- or current_object.has_forge_label("flood_obj")
				      -- scripted music of power down sound
			         if current_object.is_of_type(initial_spawn_point) then
			            game.play_sound_for(all_players, boneyard_generator_power_down, true)
			         end
			         if current_object.is_of_type(flag_stand) then							-- removed for space
			            game.play_sound_for(all_players, inv_cue_spartan_win_1, true)
			         end
			         -- scripted explosions
			         if current_object.is_of_type(soccer_ball) or current_object.is_of_type(golf_ball) then
			            global.object[8] = current_object.place_between_me_and(current_object, bomb, 0)
				         global.object[8].number[7] = 6666
					      --current_object.object[0].delete()
			         end
			         --if current_object.is_of_type(golf_ball) then
			            --global.object[8] = current_object.place_between_me_and(current_object, covenant_bomb, 0)
				         --global.object[8].number[7] = 6666
					      --current_object.object[0].delete()
			         --end
                  -- mid-phase killing and deletion (inv_gates) of target objects.
	               current_object.kill(false)
	-- Removed: failed to delete scenery like crates & barricades. these would despawn after about 30 sec, probs due to garbage collection. seems like they can be killed, with no visible difference, then garbage collect.
   -- NOTE removing this has broken the detached turret creation in Alexandria in Ruin FUUUUUUUUUU			--> wait no lol, that's a special case is_of_type(machine_gun_turret) in_gates thing for winter contingency script.
	-- Added back. I've decided that the ability to script explosions of fusion coils, vehicles  n stuff, and make detached turrets, is valuable enough. Just don't use scenery objects with brown team.
			      -- don't delete dead vehicles or turrets. scenery objects will garbage collect.
			         global.number[10] = current_object.health()		
	               if global.number[10] != 0 then
	                  current_object.delete()								
	               end
			      end
	         end
		   end
	   end
   end
end


---------- Removed for space
--for each object with label "inv_weapon" do
   --if current_object.spawn_sequence > global.number[2] then 
      --current_object.delete()
  --end
--end

----- removed inv_vehicle allied waypoints for space.
--for each object with label "inv_vehicle" do

-- version 0.014d adds in something here to change timer[2] back to 10 as in vanilla, because that modded version's timer[2] is 100 by default.
--   if current_object.timer[2] > 10 then
--      current_object.timer[2] = 10
--   end

   --current_object.timer[2].set_rate(-100%)
   --current_object.set_waypoint_icon(supply)
   --current_object.set_waypoint_visibility(allies)
   --current_object.set_waypoint_priority(normal)
   --do
      --global.number[8] = 0
      --for each player do								-- removed for space. almost redundant.
         --global.number[8] = current_object.get_distance_to(current_player.biped)
         --if global.number[8] < 10 then 
         --   current_object.timer[2].set_rate(-1000%)
         --end
      --end
   --end
   --if current_object.timer[2] < 5 then 				-- removed for space. almost redundant.
      --current_object.set_waypoint_icon(none)
      --current_object.set_waypoint_priority(low)
      --if current_object.timer[2].is_zero() then 
         --current_object.set_waypoint_visibility(no_one)
      --end
   --end
--end
-- the whole above section is very unimportant. so almost redundant, it can be removed for space.

for each object with label "inv_gates" do
   if current_object.spawn_sequence < global.number[2] and current_object.spawn_sequence != 0 then 
	  --if current_object.team != team[6] then 	--or current_object.number[5] == 2700 then
      --if current_object.is_of_type(machine_gun_turret) then
	     --current_object.place_at_me(detached_machine_gun_turret,none,none,0,0,3,none)
		 --current_object.delete()
	  --end
	   current_object.kill(false)
	  -- don't delete dead vehicles or turrets			-- removed. failed to inv_gates certain objects like scenery, including covenant shield, barriers, elite drop pods.
	  --global.number[10] = current_object.health()
	  --if global.number[10] != 0 then
	   current_object.delete()
	  --end
	  --end
   -- delayed deletion of brown team
      --if current_object.team = team[6] and current_object.number[5] == 1 then
         --current_object.kill()
	     --current_object.delete()
	  --end
	  -- added for non-deletable objects (pelicans, phantoms, kill zones, portable shields)					-- turns out these are deltable, just not respawnable.
	  --if current_object != no_object then
		 --global.object[8] = current_object.place_between_me_and(current_object, hill_marker, 0)
		 --current_object.attach_to(global.object[8], 0,0,0,relative)
		 --global.object[8].delete()
	  --end	  
   end
-- attach to a hill marker for invisible teleporters. Yellow team.
   --hide_teleporter()
   --if current_object.team == team[5] and current_object.object[1] == no_object then
	  --current_object.object[1] = current_object.place_between_me_and(current_object, hill_marker, 0)
	  --current_object.attach_to(current_object.object[1], 0, 0, 0, relative)
   --end
end










-- precise inv_vehicle function (saves space because called 3 times). Also now the phase transition function (contains all non-phase-specific calls)
function precise_inv_vehicle()
   --if global.number[2] < 3 then
      --for each player do
         --game.show_message_to(current_player, none, "Support these mods!   ko-fi.com/RabidMagicMan")
         --current_player.set_round_card_title("")					-- That's pretty odd. sets a blank card, which gets overridden by specific text elsewhere. probably redundant.
      --end														--> NOT redundant! This is for removing the card. without it, card never goes away.
   --end
   --attacker_team.score += 1            -- 1 redundant action. can remove this if you change other conditions which check attacker_team.score into global.number[2] checks instead. it's just phase.
   --attacker_team.number[4] += 1
   --global.timer[2].reset()    -- "under_attack" announcement resets on phase end
   game.round_timer = script_option[2]    -- condensed into 1 script option to save script space
   global.number[4] = 0			-- Phase end trigger gets toggled off
   --game.sudden_death_timer.reset()      -- sudden death removed
   team[0].number[0] += global.number[2]     -- new summative scoring.        pseudo-global number stores number of points gained in previous phase and roll over those points again next phase. 
   global.number[2] += 1		-- increase phase number
   game.show_message_to(all_players, none, "Join our server!   rabid.tiny.us/discord")
   for each player do
      if current_player.team == team[0] then
         --current_player.score += global.number[2]	      -- cheaper phase scoring.     p1 = 2 points, p2 = 3 points, p3 = 4 points.       total = 9.
         --current_player.score += team[0].number[0]        -- big summative scoring.     p1 = 2 points, p2 = 5 points, p3 = 9 points.       total = 15.       - this layout is if you do summative AFTER adding phase number
         current_player.score += team[0].number[0]          -- summative scoring.         p1 = 1 points, p2 = 3 points, p3 = 6 points.       total = 10.       - 1 action longer.
      end
      
      
      
      
      --if global.number[2] < 3 then
         --game.show_message_to(current_player, none, "Support these mods!   ko-fi.com/RabidMagicMan")
         --current_player.set_round_card_title("")					-- semi-redudant
      --end   
      for each object with label "inv_vehicle" do					 			
         if current_object.spawn_sequence == global.number[2] then 		-- and global.object[4] != no_object then 
		      current_object.detach()       -- added for non-deletable and non-respawning objects (pelicans, phantoms, kill zones, portable shields)
            if current_object.object[0] == no_object then
		         current_object.delete()
		      end
         end
      end
   end
end 



-------- Phase ending / phase transitions
-- phase 1 to phase 2

-- global.number[2] is always the current phase number (1, 2 or 3. maybe 4 as well for game end, I haven't looked)
-- global.number[4] I guess signals when a phase needs to end by changing to 1
-- this repeats 3 times (once per phase transition). If you could change it into a function it'd save a lot of space! i.e. redundant parts here.
if global.number[2] == 1 and global.number[4] == 1 then 
   --if script_option[1] < 0 then
   phase_team = team[1]
   game.play_sound_for(all_players, inv_cue_spartan_win_1, true)
   --end
   --if script_option[1] > 0 then 
      --game.play_sound_for(all_players, inv_cue_covenant_win_1, true)
   --end
   --for each object with label "flood_obj" do
      --if current_object.spawn_sequence == 2 then 
         --current_object.timer[0] = script_option[7]
         --current_object.timer[1] = script_option[8]
      --end
   --end
   --global.number[3] = script_option[5]
   --game.round_timer = script_option[6]
   precise_inv_vehicle()
end

if global.number[2] == 2 and global.number[4] == 1 then 
   --if script_option[1] < 0 then 
      phase_team = team[2]
      game.play_sound_for(all_players, inv_cue_spartan_win_2, true)
   --end
   --if script_option[1] > 0 then 
      --game.play_sound_for(all_players, inv_cue_covenant_win_2, true)
   --end
   --for each object with label "flood_obj" do
      --if current_object.spawn_sequence == 3 then 
         --current_object.timer[0] = script_option[11]
         --current_object.timer[1] = script_option[12]
      --end
   --end
---------------------------------------------- removed for phantom turret
-- Rabid added. put turret operator back in their body on P2-->P3 transition, when controls move.
      --if current_player.object[1] != no_object then			
       --  global.number[10] = current_player.object[1].health	
	    -- if global.number[10] > 0 then
	     --   current_player.set_biped(current_player.object[1])
	     --end
      --end
-- End of Rabid added.
----------------------------------------------
   --end
   --global.number[3] = script_option[9]
   --game.round_timer = script_option[9]
   precise_inv_vehicle()
end


------------------ hybridised p3-->p4 transition
if global.number[2] == 3 and global.number[4] == 1 then 
   --if script_option[1] < 0 then 
      phase_team = team[3]
      game.play_sound_for(all_players, inv_cue_spartan_win_big, true)
      send_incident(inv_spartan_win, all_players, no_player)
   --end
   --if script_option[1] > 0 then        -- redundant. redundancy here. luxury. elites aren't the attacking team in WC (unless you change it for them to be), so this can be removed if needed.
      --game.play_sound_for(all_players, inv_cue_covenant_win_big, true)
      --send_incident(inv_elite_win, all_players, no_player)
   --end
   --global.object[4].number[3] = 40          -- unused
   --- I've moved the += 10 points to here.
   --for each player do
      --if current_player.team == team[0] then 
         --current_player.score += 10
      --end
   --end
   precise_inv_vehicle()
   ---
end

























--------- Objective types: detect from map
-- removed. 
-- default generators
--global.number[3] = 3


-- prevent waypoints n shit on indestructible map objects at end of game. doesn't matter much though.		-- nah, redundant. just use spawn seq 5 for flood_obj objects for invincibility
--if global.number[2] >= 4 then
   --global.number[3] = -1
--end

-- description: Campaign armor; berserkers; extra forge tools; drop pods; drop shields; more! Mod: Rabid MagicMan. Msg for info! 33x scale. v20
-- description: Campaign armor; berserkers; extra forge tools; drop pods; drop shields; more! Mod: Rabid MagicMan. Msg for info/help! 33x scale


-- redundancy. I could hardwire this, or else make it map-defined instead of script_option defined.
----------- Territories, assault, CTF script option reading
---- Read script options				-- bomb's disarm time resets every single tick :O something else must read this and get assigned, instead of it using global.object[0].timer[1] directly.




-- redundancy. I could hardwire this, or else make it map-defined instead of script_option defined.
----------- Territories, assault, CTF script option reading
   --global.team[1].number[0] = script_option[4]
   --if global.number[2] == 2 then 
      --global.team[1].number[0] = script_option[7]
   --end
   --if global.number[2] == 3 then 
      --global.team[1].number[0] = script_option[10]
   --end




--alias cap_defense_timer = team[3].timer[3]			-- global.object[4].timer[3]	--> crashes after loading screen when I set it to this. Same if I use global.object[2].timer[3]. odd. ah well, only 1 action longer to use a team.timer[3] instead.
--alias cap_idle_bomb_reset = team[3].timer[2]
--alias cap_offense_timer = global.team[1].number[0]


--if global.number[3] == 1 then 
   --set_scenario_interpolator_state(2, 0)
   --set_scenario_interpolator_state(1, 0)
--end


------- removed since adding map specific objective detection
--function objective_waypoint()
   --current_object.set_waypoint_timer(0)
   --current_object.object[0].set_waypoint_timer(0)
--end

--------- This should be placed before global.object[0] deletion sections.
---- core/bomb killer medal
-- removed flood.




-------------- Flood Inundation objective set up:
-- capture time = spawn sequence 
-- phase = team   (blue = p1, green = p2, orange = p3
-- compulsory = negative spawn sequence                                    -- errrrr hill_marker maybe? negative spawn sequence? <-- actually yh negative spawn seq would be perfect.




--for each object with label "flood_obj" do           -- moved
   --current_object.set_progress_bar(0, no_one)
--end

--function objective_waypoints_V2()


---- removed some seemingly redundant lines. why would an objective ever have spawn permissions, for instance?
for each object with label "flood_obj" do
   --current_object.set_spawn_location_permissions(no_one)
   --current_object.set_invincibility(1)
   --current_object.set_pickup_permissions(no_one)
   current_object.set_progress_bar(0, no_one)
   current_object.set_waypoint_visibility(no_one)
   current_object.set_shape_visibility(no_one)
   if current_object.team[0] != phase_team then 
      current_object.object[0].delete()
	   --current_object.object[1].delete()       -- v23 removed. combined sound emitter and defense waypoint hill marker into same object.
   end
end

------ all except generators
for each object with label "flood_obj" do
   if current_object.team[0] == phase_team then         --removed conditon flood -- and global.number[3] < 4 then 
      --objective_waypoints_V2()
      --function objective_waypoints_V2()
      current_object.set_waypoint_visibility(allies)
      current_object.set_waypoint_icon(defend)
      current_object.object[0].set_waypoint_visibility(enemies)      -- LUXURY. You could save around 6-8 actions by removing waypoint from the siren object sound_emitter_alarm_1. Both teams would see ordnance icon. 
      current_object.object[0].set_waypoint_icon(ordnance)
      global.object[1] = current_object.object[0]
      global.object[1].team = global.team[0]
	   --current_object.set_waypoint_timer(none)				-- re-add?
      --current_object.set_waypoint_priority(high)			-- removed for space. 	--> added back in in case it's for cancelling blink priority.
	   current_object.set_shape_visibility(everyone)
      --current_object.object[0].set_waypoint_timer(none)	-- re-add?		-- FINAL TESTING: check if defenders can see the waypoint timer correctly for territories and CTF and assault
      --current_object.object[0].set_waypoint_priority(high)	-- removed for space	--> added back in in case it's for cancelling blink priority.
      if current_object.object[0] == no_object then           -- current_object.number[6] != -2 and
         --global.object[8] = current_object.place_at_me(spartan,none,none,0,0,0,none)     -- NPC testing
         --current_object.object[0] = current_object.place_at_me(hill_marker, none, never_garbage_collect | suppress_effect, 0, 0, 0, none)
         current_object.object[0] = current_object.place_at_me(sound_emitter_alarm_1, none, never_garbage_collect | suppress_effect, 0, 0, 0, none)
         current_object.object[0].attach_to(current_object, 0, 0, 0, relative)
         --current_object.object[1] = current_object.object[0]      -- this is redundant line, could just change every instance of object.object[1] to object.object[0], but it would take a while to find those all and do it neatly for just 1 action.
         --current_object.object[0].attach_to(current_object, 0, 0, 6, relative)			-- attach height is notably higher for generator! Keeping it out of function.
	      --if global.number[3] == 3 then
	      --current_object.timer[0] = cap_offense_timer			-- one-time setting territories' max capture time to the correct script option (instead of 30 sec default).
         --current_object.timer[0] = current_object.spawn_sequence
         
         --global.number[10] = current_object.spawn_sequence
         --if global.number[10] < 0 then       -- negative spawn seq = compulsory territories
            --global.number[10] *= -1
         --end
         --current_object.timer[0] = abs(global.number[10])
         current_object.timer[0] = abs(current_object.spawn_sequence)
      end
   end
end


-- Redundant! this is the flag spawner, not the flag itself. pointless actions!
--for each object with label "inv_obj_flag" do
   --current_object.set_spawn_location_permissions(no_one)
   --current_object.set_invincibility(1)
   --current_object.set_pickup_permissions(no_one)
   --current_object.set_waypoint_visibility(no_one)
   --current_object.set_shape_visibility(no_one)
--end

--function rehealth()
   --current_object.shields = 100
   --current_object.health = 100
   --current_object.team[0] = neutral_team  -- nesting a team literally just to make this a one-time health change. Could use an object.number mark instead. No reason not to.
--end

--function sound_the_alarm()
   --current_object.set_waypoint_priority(blink)
  -- current_object.object[0].set_waypoint_priority(blink)
   --current_object.number[4] = 1				-- turn sirens on
   --global.number[0] = 1						-- sudden death permission
   --for each player do
      --if current_player.team == global.team[0] then         -- and global.number[3] != 4 
         --script_widget[0].set_visibility(current_player, true)
      --end
   --end
   
   -- changed to proc once per phase. Cheaper and less annoying.     -- resets on phase transition
   -- probably would've worked fine, but I'm now removing it for space. 
   -- Only 2 other places it needs adding back are:     constant set_rate(-100%)   precise_inv_vehicle phase transition reset.
   --if global.timer[2].is_zero() then
      --if global.number[2] == 1 then
         --game.play_sound_for(global.team[0], announce_a_under_attack, true)
      --end
      --if global.number[2] == 2 then
         --game.play_sound_for(global.team[0], announce_b_under_attack, true)
      --end
      --if global.number[2] == 3 then
         --game.play_sound_for(global.team[0], announce_c_under_attack, true)
      --end
   --end
   
   
   
   --if current_object.number[0] == 1 and global.timer[2].is_zero() then 
      --game.play_sound_for(team[1], announce_a_under_attack, true)
      --global.timer[2].reset()
   --end
   --if current_object.number[0] == 2 and global.timer[3].is_zero() then 
      --game.play_sound_for(team[1], announce_b_under_attack, true)
      --global.timer[3].reset()
   --end
   --if current_object.number[0] == 3 and global.timer[7].is_zero() then 
      --game.play_sound_for(team[1], announce_c_under_attack, true)
      --global.timer[7].reset()
   --end
--end


--- troubleshooting
--for each object do
   --if current_object.team == team[5] then
      --current_object.set_waypoint_visibility(everyone)
   --end
--end



---- Fixed
-- Original. Contains a weird bug that prevents tele senders from spawning in if set at 'place at start false' with a high-ish number (51 is high enough to be bugged, 20 isn't).
-- This bug occurs despite the fact the tele sender has neutral team, no label, 0 spawn sequence. very strange indeed.
-- setting an object's team to team[2] in forge will halve its hp. Setting it to team[7] will double its hp.

-- flood removed for space
---- Health doubling and halving Fix again! Turns out some objects die or delete automatically if you change their health in any way. e.g. teleporters, hill markers, scenery. 
--   you can exclude these objects by doing a health == 100 check before trying to modify their health.
--for each object do
   --if current_object.team[0] == no_team and current_object.team == team[5] or current_object.team == team[7] then		
      --current_object.max_shields *= 2
	  --global.number[10] = current_object.health
	  --if global.number[10] == 100 then
	     --if current_object.team == team[5] then
            --current_object.max_health /= 2
		 --end
		 --if current_object.team == team[7] then
            --current_object.max_health *= 2
		 --end
		 --current_object.health = 100
         --current_object.team[0] = neutral_team 		    -- nesting a team literally just to make this a one-time health change. Could use an object.number mark instead. No reason not to.
      --end 
   --end
--end

-- pink team invincible. shorter script, and consistent with AnvilEditor.
for each object do
   if current_object.team == team[7] then
      current_object.set_invincibility(1)
      current_object.team[0] = team[7]
      --current_object.team = neutral_team    -- luxury. for colour, e.g. for pelicans.
      current_object.team = no_team    -- trying this to see if waypoint stays red for 'entry point' markers on maps
   end
end


for each object with label "flood_obj" do
   current_object.timer[0].set_rate(0%)
   -- Preserve team (controls phase)                  -- Old: Preserving species-specific vehicles (green team and purple team)
   if current_object.team[0] == no_team then
      current_object.team[0] = current_object.team
	   current_object.team = global.team[0]
   end
end


--------------------------------------- issue above



--global.number[8] = 1					-- testing if redundant. depends whether the following modulo-assign %=  operator converts negative numbers into positive or not.

-- v18
-- Territories & generators & bomb sites: create sirens/alarms
--for each object with label "flood_obj" do
   --if current_object.team[0] == phase_team and current_object.object[1] == no_object then         -- and global.number[3] >= 2     -- removed condition flood
      --if current_object.number[0] == 0 then 
         --current_object.number[0] = global.number[8]
         --global.number[8] += 1
         --current_object.number[0] %= 3
         --if current_object.number[0] == 0 then 
         --current_object.number[0] += 1
         --end
      --end
      --current_object.number[0] = rand(2)
      --if current_object.number[0] == 0 then				-- if current_object.number[0] == 1 or current_object.number[0] == 3 then 
      --current_object.object[1] = current_object.place_at_me(sound_emitter_alarm_1, none, never_garbage_collect | suppress_effect, 0, 0, 5, none)
         --current_object.object[1].attach_to(current_object, 0, 0, 6, absolute)
      --end
      --if current_object.number[0] == 1 then 
         --current_object.object[1].delete()
         --current_object.object[1] = current_object.place_at_me(sound_emitter_alarm_2, none, never_garbage_collect | suppress_effect, 0, 0, 5, none)
      --end
   --end
--end 


-- default: progess.    redundancy. i think you can save an action or trigger by moding this into a 'do' block above.      Nah. saves a trigger, not an action.
global.number[4] = 1

------- Territory capturing and contesting: streamlined & cleaned
for each object with label "flood_obj" do
   if current_object.team[0] == phase_team then           -- and global.number[3] == 3
      global.number[4] = 0       -- least one territory = don't progress. compulsory territories.
      current_object.set_waypoint_timer(0)
      current_object.object[0].set_waypoint_timer(0)
	  --global.object[1] = current_object
      current_object.set_waypoint_priority(high)
      current_object.object[0].set_waypoint_priority(high)
      current_object.set_progress_bar(0, enemies)
      --current_object.number[5] = 0
      --current_object.number[3] = 0
      current_object.number[4] = 0
-- Contesting removed from Winter Contingency (for gameplay and so that monitors don't block capture)
-- Semi-Redundant: Could also remove capture time script stat just to save space.  
      for each player do
         if current_object.shape_contains(current_player.biped) then 
         -- vehicle check removed for Winter contingency.
			--global.object[3] = no_object
            --global.object[3] = current_player.try_get_vehicle()
            --if global.object[3] == no_object then 
			
			
	-- my spec ops addition (changes to 1 when in a territory)					-- removed in winter contingency.
               --current_player.number[3] = 1
               --global.object[2] = current_player.biped
               --if global.object[2].number[0] == 16 then 
                  --game.show_message_to(current_player, none, "Advanced camo disengaged (objective)")
                  --global.object[2].number[0] = 8
               --end
	-- end of my spec ops addition
               --current_object.number[5] += 1						-- number[5] is total players in the territory
               --current_object.number[3] += 1						-- number[3] is defenders in the territory
               --if current_player.team == global.team[1] and not current_player.number[1] == -3 then 					-- exclude guardian oracle monitors from capturing
			   if current_player.number[1] == 0 then	-- exclude guardian oracle monitors from capturing
				  --current_object.number[3] -= 1
                  current_object.number[4] += 1					-- number[4] is attackers in the territory.    Also turns sirens on if > 0
                  --current_player.timer[2].set_rate(-100%)
                  --if current_player.timer[2].is_zero() then 
                     --current_player.script_stat[1] += 1
                     --current_player.timer[2].reset()
                  --end
               --end
            end
         end
      end
      -- sound alarms and deplete capture time if any attackers in territory zone
      if current_object.number[4] > 0 then 				-- current_object.number[5] > 0 and 
	      --sound_the_alarm()
         --current_object.number[4] = 1				-- turn sirens on       -- redundant.
         current_object.set_waypoint_priority(blink)
         current_object.object[0].set_waypoint_priority(blink)
         --global.number[0] = 1						-- sudden death removed v11
         current_object.timer[0].set_rate(-100%)
		 -- contesting removed from Winter Contingency (for gameplay and so that monitors don't block capture)
		 -- stall capture rate (and "under attack" announcement intervals) if at least one defender is contesting the territory.
         --if current_object.number[3] > 0 then 
            --current_object.timer[0].set_rate(0%)
            --global.timer[2].set_rate(0%)
            --global.timer[3].set_rate(0%)
            --global.timer[7].set_rate(0%)
         --end
      --end
	  -- replenish capture if no attackers are in the territory and the capture bar is less than the defense timer maximum
      --if current_object.number[4] == 0 and current_object.timer[0] < cap_defense_timer then
         --current_object.timer[0].set_rate(100%)
      --end
         ----- compulsory terrirtories, flood version (negative spawn sequence).
         if current_object.timer[0].is_zero() then
            --if current_object.spawn_sequence >= 0 then
               --global.number[4] = 1           -- standard territories
            --end
            if current_object.spawn_sequence < 0 then 
               current_object.delete()          -- compulsory territories 
               game.play_sound_for(all_players, boneyard_generator_power_down, true)
            end
         end
      end
   end
end

for each object with label "flood_obj" do
   if current_object.team[0] == phase_team then           -- and global.number[3] == 3
      if current_object.timer[0].is_zero() then
         if current_object.spawn_sequence >= 0 then
            global.number[4] = 1           -- standard territories
         end
      end
   end
end

--- intention:
-- 1. no territories = progress
-- 2. 1+ complusory territory = don't progress
-- 3. 1 captured standard territory = progress





----- generators removed for now. code "FLOOD-GENERATORS"


-------- streamlined v4				compile: 3 conditons shorter than original, 0 actions shorter.       changed since v2
-- script_option[1] attacking team removed. team.score also removed.
--if game.round_timer.is_zero() and global.object[4].number[3] == 9999 then 
   --if global.number[2] == 1 then
	   --send_incident(inv_elites_win_rd1, all_players, no_player)
	--end
   --if global.number[2] != 1 then
	   --send_incident(inv_elite_win, all_players, no_player)
	--end
   --game.end_round()
--end

-------- Redundant. This is my streamlined version of the original, but Cantaloupe0 has pointed out that it's pointless. This code is for a scenario that would never naturally happen:
-- the current flag or bomb (global.object[0]) is no_object, BUT there's a power core on the map. It then assigns that powercore as the current flag and sets it properties. BUT it already does that
-- down below where the power core is first spawned in. So this IF criteria should be impossible ever be satisfied. So pointless.
-- the only time an imposisble scenario like this could arise if some variable like global.object[0] got lost during a host migration. BUT a recent update has removed host migrations from the game!
----- (Now a lobby, whetehr private or CGB, will always just end for everyone if a host migration needs to happen).

--if global.number[3] == 1 and global.object[0] == no_object then 
--   for each object do
--      if current_object.is_of_type(covenant_power_core) or current_object.is_of_type(unsc_data_core) then 
--         global.object[0] = current_object
--         global.object[0].number[0] = 2
--         global.object[0].team = global.team[0]
--         global.object[0].set_pickup_permissions(enemies)
--         global.object[0].set_weapon_pickup_priority(high)
--         global.object[0].set_waypoint_icon(flag)
--         global.object[0].set_waypoint_priority(high)
--      end
--   end
--end


-- Removed for streamling into the above. redundant.
   --if global.object[0] == no_object then 
   --   for each object do
   --      if current_object.is_of_type(unsc_data_core) then 
     --       global.object[0] = current_object
     --       global.object[0].number[0] = 2
      --      global.object[0].team = global.team[0]
     --       global.object[0].set_pickup_permissions(enemies)
      --      global.object[0].set_weapon_pickup_priority(high)
     --       global.object[0].set_waypoint_icon(flag)
      --      global.object[0].set_waypoint_priority(high)
      --   end
    --  end
   --end
--end


--for each object with label "inv_platform" do									-- try removing this for script space, and see what happens.
--   if script_option[13] == 2 and current_object.spawn_sequence == 5 then 
--      current_object.set_device_power(0)
--      if global.number[3] == 1 then 
--         current_object.set_device_power(100)
--      end
--   end
--end






-- moved into the above loop (to save redundant space). This section doesn't even mention "current_player" once lol, it's pointless under its own loop.
--for each player do	
--   if global.number[3] == 1 and global.player[0].killer_type_is(kill) then 
--      global.player[1] = global.player[0].try_get_killer()
--      send_incident(flagcarrier_kill, global.player[1], global.player[0])
--      global.player[0] = no_player
--   end
--end

----------- redundant. impossible scenario AND this conflicts with my ODST drop pods: if bomb resets when drop pods are on the map, it turns one of the drop pod bombs into an objective lmao.
--if global.number[3] == 2 and global.object[0] == no_object then 
   --for each object do
      --if current_object.is_of_type(bomb) then 
         --global.object[0] = current_object
         --global.object[0].number[0] = 12
         --global.object[0].team = global.team[0]
         --global.object[0].set_pickup_permissions(enemies)
         --global.object[0].set_weapon_pickup_priority(high)
         --global.object[0].set_waypoint_icon(bomb)
        --global.object[0].set_waypoint_priority(high)
      --end
   --end
--end




--------------------------- streamlining. ALL CTF (streamlined)
-- removed FLOOD CTF 000



----------- terms
-- global.object[0]						flag
-- global.object[0].number[0] == 2	    flag being carried by a player, OR has been dropped this tick (then gets set to global.object[0].number[0] == 3)
-- global.object[0].number[0] == 3	    flag dropped.
-- global.player[0]                	    previous carrier of the flag. needed to identify the flag carrier after it's been dropped, like for giving a medal if this player has been killed.
-- team.object[0] 						destination zone
-- global.object[0].timer[1]			return timer. when reaches zero, core gets deleted. counts up if idle, counts down if defenders in its shape.








---- disarm is gonna be object.timer[3]. Same with ctf return. the difference is that flag gets its timer[3] overridden to phase a specific value.



------ Assault removed. FLOOD ASSAULT 000




------ Flag & bomb taken/dropped incidents
-- flood removed

----- Removed in winter contingency, conflicts with survivor victory end_round due to reusing global.timer[4]
-- brute berserker passive regen
-- my addition. global timer for little extra healing of brutes. in brute's section, they each get 1 hp every tick that this timer is zero (5 times a second).
-- +2 hp ~3 times a sec, for 17 second full regen on its own. ~12 sec combined regen from testing. If still too weak, change this to -400% rate for 12.5 sec full regen.
   --global.timer[4].set_rate(-300%)
   --if global.timer[4].is_zero() then
      --global.timer[4].reset()
   --end
--end


--------------------------------------- End of Assault & Flag/CTF/core ----------------------



--------------------------- objectives above (end of assault will be here).





------ doesn't save an action to remove this single use function.
function combat_form_appearance()
            ----- human flood combat form appearance
               --global.object[9] = global.object[3].place_between_me_and(global.object[3], skull, 0)
               --global.object[9].number[6] = 400
               --global.object[8] = global.object[9].place_at_me(hill_marker, none, none, 0, 3, 0, none)
               --global.object[9].attach_to(global.object[8], 0,0,0,relative)
               --global.object[8].copy_rotation_from(global.object[3], true)
               --global.object[9].detach()
               --global.object[8].delete()
            ----- 
               --global.object[9].attach_to(global.object[3], -1,0,5,relative)
            
            --game.show_message_to(all_players, none, "create")
            
         --end
   --duoskullvertical()
--function duoskullvertical()            -- single use function. redundancy here.
              
               global.object[9] = global.object[3].place_between_me_and(global.object[3], skull, 0)
               global.object[10] = global.object[9].place_between_me_and(global.object[3], flag_stand, 0)
               global.object[11] = global.object[3].place_between_me_and(global.object[3], health_pack, 0)
               global.object[11].attach_to(global.object[9], 0, 0, 0, relative)
--global.object[11].team = team[0]
               global.object[8] = global.object[9].place_at_me(sound_emitter_alarm_2, none, none, 10, 0, 5, none)
               --global.object[10].face_toward(global.object[10], -63, -75,0)
               --global.object[11].attach_to(global.object[8], 0, 0, 0, relative)
               global.object[10].face_toward(global.object[10], -1, 0,0)
               global.object[10].attach_to(global.object[8], 0, 0, 0, relative)
               global.object[8].face_toward(global.object[8], -1,0,0)
               global.object[9].attach_to(global.object[10], 0, 0, 0, relative)
               -- get heading aligned with spawing biped
               global.object[8].copy_rotation_from(global.object[3], true)
               -- rotate further (fine tuned appearance for spartans)
               
               


               global.object[9].detach()
               global.object[11].detach()
               --- [10] doesn't get used in the end. Is it needed as a chaperone?
               --- [8] also not used in end.
               --global.object[8].delete()         -- oh no actually this gets used in human version.
               global.object[10].delete()
               
               global.object[11].attach_to(global.object[8], 1, 0, 0, relative)
               global.object[8].number[6] = 50
               
               global.object[9].attach_to(global.object[3], 0, 0, 5, relative)
               --global.object[8].face_toward(global.object[8], -1,1,0)
               --global.object[10].detach()
               --global.object[8].delete()
               --global.object[8].number[6] = 60
               global.object[8].attach_to(global.object[3], 0, 0, 5, relative)
               --global.object[10].attach_to(global.object[3], -1,0,5,relative)
               
               
               --- [10] doesn't get used in the end. Is it needed as a chaperone?
               --- [8] also not used in end.
               --global.object[10].number[6] = 360
               global.object[11].number[6] = 110
               global.object[9].number[6] = 320       -- 320
               --if global.object[3].is_of_type(elite) then
                  --global.object[9].number[6] = 450
               --end
--end
   -- elite
   if global.object[3].is_of_type(elite) or global.object[3].is_of_type(bloat_bomb_type) then     -- juggernaut
      global.object[9].number[6] = 450
   -- lots of options here. 3,0,0, or 3,1,0 or 3,2,0 all have strengths n weaknesses. 
   -- bigger middle numbers have more ridges and texture, but look more recognisably skulls. smaller middle numbers have unpleasant amounts of symmetry between the two skullsf from front.
   -- negative middle number generally aren't as good. Less ridge detail from front view (which is most important view) on both stances.
   -- okay I've got it to either 3,1,0 ot 3,0,0. First has deeper ridge and slightly less symmetry, the second one has nice symmetrical wishbone veins but more unpleasant symmetry. harldy anything in it though.
      global.object[8].delete()     -- delete healthpack.      should confirm tho.

      global.object[8] = global.object[3].place_at_me(skull, none, none, 3, 1, 0, none)         
      global.object[8].number[6] = 430       -- 410      380      -- 320
      global.object[8].face_toward(global.object[3], 0,0,0)
      --global.object[8].attach_to(global.object[3], 0, 0, 6, relative)
      --global.object[8].attach_to(global.object[3], 1, 0, 5, relative)         -- size 320 at height 1,0,5 is pretty good. covers neck in both sword n rifle stance, but leaves head entirely exposed.
      --global.object[8].attach_to(global.object[3], 2, 0, 5, relative)         -- jaw. Lots of constant swaying, especially for sword stance. vry cool. BUT 1st person intense flame in face.
      global.object[8].attach_to(global.object[3], 1, 0, 5, relative)         -- size 320 at height 1,0,5 is pretty good. covers neck in both sword n rifle stance, but leaves head entirely exposed.
   end
end






---------------------- Ten pin





alias temp_obj1 = global.object[7]
--alias temp_obj2 = global.object[8]
--alias lifetime = object.number[1]
--alias bounce_ticks = object.number[2]
--alias bounce_check = object.number[0]
--alias stone = object.object[3]


----- v2
for each object with label 0 do
   --if current_object.team != team[2] then       -- infected grenade (to reduce lag)
      --global.number[10] = 0                      -- testing redundant
      global.number[10] = current_object.health
      -- health projectiles only (grenades & rockets)
      if global.number[10] == 100 then
	      temp_obj1 = current_object
         for each object do
            if current_object == temp_obj1 then 
               global.number[10] = 1
            end
         end
	     -- object is a health projectile. 
         if global.number[10] == 100 then
	 -- Change grenade things only once it's left thrower's hand, otherwise that info gets wiped on client grenades
            --global.number[10] = -2
            --current_object.set_invincibility(1)
			   
            --for each object do
               --if global.number[10] != 0 and current_object.is_of_type(spartan) or current_object.is_of_type(elite) then 
                  --global.number[10] = current_object.get_distance_to(temp_obj1)
               --end
            --end
            
            -- one condition shorter. WARNING this might cause problems if a player dies whilst throwing a grenade. not sure though.
            --for each player do
               --if global.number[10] != 0 and current_player.biped != no_object then
                  --global.number[10] = current_player.biped.get_distance_to(temp_obj1)
               --end
            --end
            

			   if current_object.team != team[2] then       -- global.number[10] != 0 and 
               --game.show_message_to(all_players, none, "inv_weapon")
               -- wait actually this does nothing because the object.number[6] scaling loop isn't using a magic label (so doesn't look at projectiles)
               -- oh but it does in riot and medieval invasion. so maybe I will want to add this at some point to hide frags from clients.
               --current_object.number[6] = 10       -- huh this seems like a bad idea. host will probably attach player closer to frag than client does.
               
			      --current_object.lifetime += 1		-- troubleshooting: I've changed this, might cause issues now.
			      --- scarab AI closest player
	            global.number[11] = 50		-- 20       -- set max range here, if wanted.
               --if current_object.lifetime == 1 then
			         for each player do
                     if current_player.biped != no_object then
                        global.number[10] = current_object.get_distance_to(current_player.biped)
                        if global.number[10] < global.number[11] then 				-- or global.object[12].player[0] == no_player		--> I think this OR criterion is redundant now.
                           --current_object.player[0] = current_player
                           global.player[4] = current_player
                           global.number[11] = global.number[10]
                           --game.show_message_to(all_players, none, "inv_vehicle")
			               end
		               end
                  end
            -- If projectile has left owner's hand, and it hasn't been looked at on a previous tick.
                  if global.number[11] != 0 then
                     current_object.team = team[2] -- turn off loop
			         --global.player[4] = current_object.player[0]
                  global.object[2] = global.player[4].biped
                  global.object[6] = global.player[4].try_get_weapon(primary)
                  global.object[5] = global.player[4].try_get_armor_ability()
		            --if not global.object[6].is_of_type(rocket_launcher) and not global.object[6].is_of_type(grenade_launcher) then    -- and current_object.lifetime == 1 then
		          --if current_object.object[3] == no_object then       --  and current_object.lifetime == 1 and current_object != no_object then			-- last criterion probs redundant.
                  -- 3
                  -- leap
                  --if global.object[6].is_of_type(energy_sword) or global.object[6].is_of_type(skull) or global.object[6] == no_object then      -- change to class numbers eventually.
                  
                  -- potential function: floor check. very short though.
                  -- WARNING. This floo check is done by host, so it won't detect clientside floating platforms from wall climbing. So unless you move this to client, it'll be impossible to leap
                  -- from walls / from climbing :'(
                  -- last two conditions: exclude ranger form, exclude transforming stalker.
                  if global.object[2].number[7] == 5 or global.object[2].number[7] == 19 or global.object[2].number[7] == 26 or global.object[2].number[7] == juggernaut_ID and not global.object[6].is_of_type(rocket_launcher) then   --and not global.object[2].number[4] == 1 and not global.object[5].timer[2] > 0 then
                     --game.show_message_to(all_players, none, "create")
                     
                     --wall_proximity_check()
                     --test_obj = extremity.place_at_me(bomb, none, none, 0,0,0, none)
                     --global.number[8] = test_obj.get_distance_to(extremity)
                     --test_obj.delete()        -- troubleshooting
                     
                     
                     --global.object[8] = global.object[2].place_at_me(bomb, none, none, 0,0,0, none)
                     --global.number[8] = global.object[8].get_distance_to(global.object[2])
                     --global.object[8].delete()        -- troubleshooting
                     
                     --global.object[8] = global.object[2].place_at_me(monitor, none, suppress_effect, 0,0,0, none)
                     -- last two conditions: exclude ranger form, exclude transforming stalker.
                     --if not global.object[2].number[4] == 1 and not global.object[5].timer[2] > 0 then 
                        --global.object[8].set_shape(box, 50, 50, 2, 1)
                     --end

---- add spinning bomb wall check function here. it'll be host this time though.    host wall check.

                     --if global.object[8].shape_contains(global.object[2]) then
                        -- based on Warp Zealot
                        --global.player[4].object[2] = current_object     -- leap attach target is grenade, for use on local.
         
         
         
         ------------ floor detection setup
                     alias floor_check_monitor = allocate temporary object
                     floor_check_monitor = global.object[2].place_at_me(monitor, none, suppress_effect, 0,0,0, none)
                     -- exclude ranger form, exclude transforming stalker.
                     if not global.object[2].number[4] == 1 and not global.object[5].timer[2] > 0 then 
                        floor_check_monitor.set_shape(box, 50, 50, 2, 1)
                     end
                     --     <-- you could add host wall check here. spinning bomb wall check function here, host this time.   
                     if floor_check_monitor.shape_contains(global.object[2]) or global.object[2].number[7] == juggernaut_ID then
         ----------- floor detection setup bottom
                        -- bomb version. 
                        --  - 6 actions instead of 1   + saves 1 condition   + supposedly the frag will be hidden more instantly.      
                        --  + using bomb instead of frag means you can't leap through invisible walls (e.g. 1% scale grids)
                        -- to revert, comment out all these below lines. then re-add the above line, and re-add the shape_contains condition and 'end' below.
                        --global.player[4].object[2] = global.object[2].place_at_me(bomb, none,suppress_effect,0,0,0,none)      -- has the same rotation as the biped.
                        global.player[4].object[2] = global.object[2].place_between_me_and(global.object[2], bomb, 0)      -- has the same rotation as the biped.
                        global.player[4].object[2].attach_to(current_object, 0,0,0,relative)
                        global.player[4].object[2].detach()
                        --global.player[4].object[2].set_scale(1)            -- I think this isn't syncing for clients. If you number[6] it you'll need to change attach distance tho.
                        global.player[4].object[2].set_invincibility(1)
                        global.player[4].object[2].set_pickup_permissions(no_one)
                        --global.object[6] = global.player[4].object[2]       
                        --global.object[6].number[6] = 1                     -- testing redundant. gonna set_scale on local when leap occurs (under local_leap)
                        
                        --current_object.delete()                          -- actually i can just comment out the condition below.

                        --current_object.set_scale(1)
                        --global.object[2] = global.player[4].biped
                        global.object[2].timer[2] = 4
                        --global.object[2].timer[2].set_rate(-1000%)    -- testing it slower
                        global.object[2].timer[2].set_rate(-200%)
                        
                        -- Leap cooldown
                        global.object[2].timer[3].reset()
                        --global.object[2].timer[3] = 33      --      <-- this would maintain the full 11 second cooldown from before v17
                        global.object[2].timer[3].set_rate(-300%)
                        
                     --end
                     --if global.number[8] == 0 then                    --if global.number[8] > 1 then
                     --if not floor_check_monitor.shape_contains(global.object[2]) then                           -- commented out in bomb version.
                     
                     
                        -- bloat_bomb     blister sac       blister bomb      bloater bomb
                        if global.object[2].number[7] == juggernaut_ID then
                           --global.object[9].delete()
                           --global.object[3] = current_object.place_between_me_and(current_object, bloat_bomb_type, 0)
                           --corpse_blobs()  -- REMOVED.
                           global.object[3] = global.player[4].object[2]
                           combat_form_appearance()
                           --global.object[9] = global.object[3]
                           global.object[3].number[7] = ballooning_ID
                           global.object[3].player[0] = global.player[4]   -- parasite daddy                        
                           --global.object[3].player[1] = global.player[4]   -- needed for ballooning to work     actually I can probably use an 'or is_of_type' condition instead.
                           --global.object[3].number[6] = 1
                           --global.object[9].set_invincibility(1)
                           --global.object[9].set_pickup_permissions(no_one)  -- can maybe do a single on local loop for all bomb object for this instead. same with invincibility.
                           -- Swarm Throw    -4 actions
                           -- this isn't working here, and I don't understand why :(      it deletes all swarm members except one, which gets scaled down to 100 size.
                           --for each object with label "p66" do
                              --if current_object.object[2] == global.object[2] then
                                 --current_object.object[2] = global.object[3]
                                 --current_object.attach_to(global.object[3], 0,0,0,relative)
                                 --current_object.detach()
                              --end
                           --end
                        end
                     
         ----------- floor detection cleanup
                     end
                     floor_check_monitor.delete()
                     current_object.delete()
         ----------- floor detection cleanup bottom

                     
                     
                     
                  end
                  -- throw parasite
                  --if not global.object[6].is_of_type(energy_sword) and not global.object[6].is_of_type(skull) and not global.object[6] == no_object then
                  if global.object[2].number[7] == 4 or global.object[2].number[7] == 33 then -- or global.object[2].number[7] == juggernaut_ID then
                     --game.show_message_to(all_players, none, "inv_gates")
                     --global.object[2] = current_object
                     --global.object[2].player[0] = global.player[4]      -- daddy
                     --global.object[2] = global.player[4].biped
                     --global.number[10] = global.object[2].number[1]     -- normal carriers throw 1, empowered carriers throw 3.
                     global.number[10] = 1
                     infection_skull()
                     -- bloat_bomb     blister sac       blister bomb      bloater bomb
                     --if global.object[2].number[7] == juggernaut_ID then
                        --global.object[9].delete()
                        --global.object[3] = current_object.place_between_me_and(current_object, bloat_bomb_type, 0)
                        --corpse_blobs()  -- REMOVED.
                        --combat_form_appearance()
                        --global.object[9] = global.object[3]
                        --global.object[9].number[7] = ballooning_ID
                        --global.object[9].player[1] = global.player[4]   -- needed for ballooning to work     actually I can probably use an 'or is_of_type' condition instead.
                        --global.object[9].player[0] = global.player[4]   -- parasite daddy                        
                        --global.object[9].number[6] = 1
                        --global.object[9].set_invincibility(1)
                        --global.object[9].set_pickup_permissions(no_one)  -- can maybe do a single on local loop for all bomb object for this instead. same with invincibility.
                     --end
                     
                     -- swarm throw
                     --global.object[8] = current_object
                     --for each object with label "p66" do
                        --if current_object.object[2] == global.object[2] then
                           --current_object.object[2] = no_object
                           --current_object.attach_to(global.object[8], 0,0,0,relative)
                           --current_object.detach()
                        --end
                     --end
                     
                     global.object[9].attach_to(current_object, 0,0,0,relative)
                     global.object[9].detach()
                     --global.object[9].object[0].health = 90     -- swarm throw airburts (try to make thrown thrall parasites shotgun airburst).
                     current_object.delete()
                  end
			      end
			   end
			end
	   end
   --end
end



-- floor collision check from TF2 soldier rocket jumps
--
               --global.object[5].object[1] = current_player.biped.place_at_me(monitor, none, none, 0, 0, 0, none)
               --global.object[5].object[1].set_shape(box, 50, 50, 2, 1)
               --global.object[5].object[1].set_scale(20)					-- confirmed redundant
               --current_player.timer[3].reset()
               --current_player.number[1] = 2									-- this player.number could be a biped.number, such as global.object[2].number[1]
               --if global.object[5].object[1].shape_contains(global.object[2]) then 
--

alias client_master = global.object[15]         -- Lasting. For clients anyway.
alias the_local_player = global.player[5] -- local player reference, according to the machine its stored on


-- based on warp zealot.
function local_leap()
   for each player do
         if current_player.object[2] != no_object then
            --game.show_message_to(current_player, none, "inv_gates")
            global.object[2] = current_player.biped
            current_player.frag_grenades = 0
            current_player.object[2].set_scale(1)
            -- leap cooldown        -- v17 moved up
            --global.object[2].timer[3].reset()
            --global.object[2].timer[3].set_rate(-300%)
            if global.object[2].number[7] != juggernaut_ID then
               --current_player.biped.attach_to(current_player.object[2], 0,0,0,relative)      -- this needs to be moved to 'on local'. Gamergotten says it's vital that host AND client do the attachment, so standard 'on local' is ideal.
               --global.object[2].attach_to(current_player.object[2], 0,0,-5, absolute) 
               global.object[2].attach_to(current_player.object[2], 0,0,-2, absolute) 
               global.object[2].detach()
               --current_player.object[2].set_scale(1)
               --global.player[4].object[2].set_scale(1)         -- sometimes it doesn't scale down when only host does it alone.
               --game.show_message_to(all_players, none, "inv_vehicle") 
               if global.object[2].timer[2] <= 2 then   -- deletes after 1 second (4 start, -200% rate)             -- <= 3 looks and feels the best. works great for europe players.     try <= 1 if it's rarely working in CGB or for bad ping players.
                  --global.object[2].detach()	
                  --global.object[2].copy_rotation_from(global.object[2], true)
                  -- host deletes the grenade
                  --if global.object[4] != no_object then
                  if host_indicator == host_ID then
                     current_player.object[2].delete()
                     -- leap cooldown        -- v17 moved up
                     --global.object[2].timer[3].reset()
                     --global.object[2].timer[3].set_rate(-300%)
                  end
                  --current_player.object[2] = no_object
                  
                  --game.show_message_to(all_players, none, "create")
               end
            end
         end
   end
end

-- based on Gamergotten implying that client-only teleport works for < 30 distance.

-- the_local_player_leap() 
-- removed to snippets. You can simply comment out local_leap() function and add this one back if you want it.





------ Luxury??? Do you REALLY need sudden death and grace time in Flood Inundation?? Probably not right?

--------------------------- objective section ending updated 
for each object with label "flood_obj" do
   -- removed for space. semi-redudant luxury. global.timer[5] things removed too.
   --if not global.timer[5].is_zero() then 
      --current_object.set_waypoint_priority(blink)
      --current_object.object[0].set_waypoint_priority(blink)
   --end
   global.object[1] = current_object.object[0]
   global.object[1].timer[0] = current_object.timer[0]
end

------ Survivor win musical outro
if global.timer[1].is_zero() then 
   send_incident(infection_survivor_win, all_players, all_players)
   -- moved spartan win += 10 score from here to under win_big (invasion incident). Now points are awarded straight away, so people won't lose out to round end betrayals and falling sabres lol.
   game.end_round()		
end
if global.number[2] == 4 then    --or team[1].number[5] == -343 then	       -- attacker_team.score == 3 or attacker_team.number[4] == 3              		--or attacker_team.number[4] == 3 or team[1].number[5] == -343 then 		-- troubleshooting							-- Winter contingency uses attacker_team.number[4] the same as invasion uses attacker_team.score!
   global.timer[1].set_rate(-200%)
end



--if not game.round_timer.is_zero() then 
   --game.grace_period_timer = 0
   --global.timer[0].set_rate(-100%)
   --global.timer[0] = 0
--end

   -- sudden death removed.

--if game.round_timer.is_zero() then        -- and not global.object[4].number[3] == 999 then
   --if global.number[0] == 1 then        -- sudden death removed v11
      --game.sudden_death_timer.set_rate(-100%)
      --game.grace_period_timer.reset()
      --if game.sudden_death_timer > 0 and game.grace_period_timer > game.sudden_death_timer then 
         --game.grace_period_timer = game.sudden_death_timer
      --end
      -- I'm using this as a number toggle. only leaving it as a timer to keep it the same variable as original used. can be chanegd if needed.
      --if global.timer[0].is_zero() then         
         --global.timer[0] = 1

         --send_incident(sudden_death, all_players, all_players)
         --global.timer[0].reset()
         --global.timer[0].set_rate(-100%)
      --end
   --end
   --if global.number[0] == 0 then 
      --game.grace_period_timer.set_rate(-100%)
      --if game.grace_period_timer.is_zero() then     -- and not global.object[4].number[3] == 999 then 
         --global.object[4].number[3] = 9999
      --end
   --end
   --if game.sudden_death_timer.is_zero() then        -- and not global.object[4].number[3] == 999 then 
      --global.object[4].number[3] = 9999
   --end
   --game.end_round()
--end


------ v11 I removed all sudden death scripts and managed to save 13 actions and 6 conditions yessssssssss fuck yes baby that's beautiful. This gametype was SO SO SO tight on actions.



















alias cumulative_total = global.number[10]
alias cycles_goal = global.number[8]
alias cycles_done = global.number[9]
alias three_percent = global.number[7]
alias point_4_percent = global.number[1]


function exp_scale()
   cycles_done += 1
   --if cumulative_total < 510 then
      --cumulative_total + 10
   --end	  
   -- put before previous one!
   --if cumulative_total > 510 then
   
   
   three_percent = cumulative_total
   three_percent /= 33
   --three_percent *= 3
   point_4_percent = cumulative_total				-- 230 got 325.34		229 got 326.32		228 got 327.32			best possible is 327.67
   point_4_percent /= 228							-- in theory (excel) 255 should be perfect, but isn't in practice. gonna trial and error this one.
   --point_4_percent *= 4
   cumulative_total += three_percent
   cumulative_total += point_4_percent
   
--current_object.set_waypoint_visibility(everyone)
   --current_object.set_waypoint_text("sc:%n g:%n", cumulative_total,cycles_goal)
   --if cycles_done > 190 then
	  --current_object.set_waypoint_icon(bomb)
   --end
   if cycles_done < cycles_goal then			-- second condition is a redundant crash failsafe			-- and cycles_done < 200
      exp_scale()
   end 
end


-- for some reason, even though this function is only used once, it doesn't save an action to insert it.
function do_local_scale()
      if current_object.number[1] == 0 and not current_object.shape_contains(current_object) and global.number[6] > 10 then 	--or global.object[8].team == team[2] or global.object[8].team == team[4] then
	      current_object.number[1] = 1
	   end
-- WARNING: make sure late spawning or purple/green team scaled objects have a shape in forge! They will fail to scale otherwise! because this now uses set_shape to perform copy_rotation only once. 
	   if current_object.number[1] == 1 or global.number[6] <= 10 then
	      -- Boolean: scripted objects.
		   if current_object.number[1] == 1 then
		      current_object.number[1] = 2
		   end
	 	   -- Boolean: unlimited objects. info at bottom
		   if current_object.number[1] == 0 then        -- and not current_object.team == team[3] then       -- 2nd condition for fallout map 1. it's to stop marked teleporter from changing shape.
	         current_object.set_shape(cylinder, 100,100,100)
         end
		 -- 327x exp scale
         cumulative_total = 100
         cycles_goal = current_object.spawn_sequence
         if current_object.spawn_sequence < 0 then 
	         cycles_goal *= 5
	         cumulative_total += cycles_goal
	         if current_object.spawn_sequence == -20 then
	            cumulative_total = 1
               --current_object.hide()
               if current_object.is_of_type(grid) then
                  current_object.set_hidden(true)
               end
	         end
	         if current_object.spawn_sequence < -20 then
	            cycles_goal = 100
		         cycles_goal += current_object.spawn_sequence
               cycles_goal += 101
	         end
         end
         if current_object.spawn_sequence < -20 or current_object.spawn_sequence > 0 then
            cumulative_total = 100
            -- COSMIC scale   15 million
            if current_object.team == team[0] then
               cumulative_total = 32732
            end
	         cycles_done = 0
            exp_scale()
         end		 
		 -- Locally detach phase physics objects from their flag stand or warthog turret before scaling and copying rotation, so that scale will work on local.
         if current_object.team == team[4] or current_object.team == team[2] then		
		      current_object.detach()
		   end
         current_object.set_scale(cumulative_total)
         current_object.copy_rotation_from(current_object, false)
         -- Aesthetic scaled forge skulls =      neutral team flag stand.
         if current_object.is_of_type(flag_stand) and current_object.team == neutral_team then
            current_object.set_scale(1)      -- not sure but this might need a copy rotation call afterwards to sync to clients. otherwise flag stnd will be big for clients still.
            current_object.copy_rotation_from(current_object, false)    -- not redundant (otherwise flag stands visible on host, but strangely not on client.

            --current_object.set_waypoint_visibility(everyone)
            --if current_object.object[0] = no_object then
            --global.object[8] = no_object     -- so that host doesn't scale the flag_stand up.
            -- v16 added condition to make sure clients don't spawn multiple skulls per flag stand in first 10 ticks of the game. Whooops...
            if host_indicator == local_ID and current_object.object[0] == no_object then  -- client-only so it looks good AND don't block bullets
               --current_object.set_scale(1)
               current_object.object[0] = current_object.place_at_me(skull, none,none,0,0,0,none)
               current_object.object[0].set_scale(cumulative_total)
               current_object.object[0].copy_rotation_from(current_object, true)      -- not redundant. this is for getting skull to face right direction, not a scale update.
               current_object.object[0].set_pickup_permissions(no_one)
               current_object.object[0].attach_to(current_object, 0,0,0,relative)
            end
         end
         --current_object.set_scale(cumulative_total)
         --current_object.copy_rotation_from(current_object, false)
         --global.object[8].set_scale(cumulative_total)
         --global.object[8].copy_rotation_from(current_object, false)
      end
end

--for each object with "scale" do
   --if current_object.is_of_type(flag_stand) and current_object.team == neutral_team then
      --current_object.set_scale(1)
   --end
--end















-- CGB kill 2nd fork
--if host_existance_check.is_zero() then
   --team[2].timer[0].set_rate(-100%)
--end



-- simplified and shadows removed.
-- purple = invincible and no collision.      green = just invincible
--function do_purple_scale()
-- moved
--end



alias client_master = global.object[15]         --global.object[11]    [-- Lasting. For clients anyway.        -- changed to [15]
alias wall_climb_master = global.object[9]
alias test_obj = global.object[8]
alias spinner = wall_climb_master.object[0]
alias extremity = wall_climb_master.object[1]

function wall_proximity_check()
   if global.number[10] < 8 and global.number[8] == 0 then
      
      --alias client_master = global.object[15]
      --alias wall_climb_master = global.object[9] 
      --wall_climb_master = client_master.object[3]
      --alias spinner = wall_climb_master.object[0]
      --alias extremity = wall_climb_master.object[1]
      
      global.number[10] += 1
      extremity.attach_to(spinner, 3, 0, 0, relative)       --   4 was good but very broad, and also can overshoot thin walls (e.g. tree tops) 
      spinner.face_toward(spinner, 1,1,0)
      extremity.detach()
      test_obj = extremity.place_at_me(bomb, none, suppress_effect, 0,0,0, none)
      global.number[8] = test_obj.get_distance_to(extremity)
      test_obj.delete()        -- troubleshooting
      --game.show_message_to(all_players, none, "inv_res_p1")
      --spinner.set_waypoint_visibility(everyone)
      --extremity.set_waypoint_visibility(everyone)
      wall_proximity_check()
   end
end



------------------------- Gamergotten's local player finder: Invasion gametype adaptation
alias the_local_player = global.player[5] -- local player reference, according to the machine its stored on
--declare the_local_player with network priority local -- must be local as this is this machines player; we dont want the host to sync their local player over the clients's

--alias host_indicator = global.team[0].number[7] -- used in figuring out which machine running 'local' is the host machine
--declare host_indicator with network priority local -- must be local as we require the clients to not see the variable we set on host, 
                                                   -- this allows us to differentiate clients from host within the on local: trigger

alias temp_obj0 = global.object[7]
--declare temp_obj0 with network priority local -- set to local as we're using this to briefly store object references on each machine

alias temp_obj1 = global.object[8]
--declare temp_obj1 with network priority local


alias host_existance_check = global.timer[3]
--declare host_existance_check = 11 -- just 1 second more than it takes for players to spawn in

-- NOTE you need to change grunt's stored secondary weapon from biped.object[3] to biped.object[0] !!!		ctrl f for "].object[3]" at start of main biped assignment.
--alias local_test_obj = object.object[3]
--declare object.local_test_obj with network priority local -- must be local as we store object references to locally created objects per machine

alias local_test_obj = player.object[3]


alias server_debug_widget = script_widget[0] -- ## OPTIONAL


-- code for host to execute
--do
-- host_indicator is set to local priority, so it will be set to 0 for clients
--if host_existance_check > 11 then
   --host_existance_check = 11
--end

--do
   --host_indicator = 1
   --host_existance_check.set_rate(-100%)
--end
-- ## OPTIONAL FOR DEBUGGING
--if host_existance_check.is_zero() and the_local_player == no_player then
   -- it must be hosted on the CGB, as the host has failed to find their player
   --host_indicator = 2 -- this number is for debugging purposes, so we can tell whether we should run CGB logic, or local customs logic
   --server_debug_widget.set_value_text("Dedicated Server ")
--end
--if the_local_player != no_player then -- it must be locally hosted if the host has found their own player
   --server_debug_widget.set_value_text("Locally Hosted ")
--end
--

alias p_biped = temp_obj0 -- temp object to store player's biped			-- NOTE I think this alias must be right before on local section.
-------------------- end of Gamergotten's local player finder



-- parasite deletion zones
for each object with label "parasite_kill" do
   --if current_object.spawn_sequence == 13 then
   --if current_object.team == phase_team or current_object.team == neutral_team then
   if current_object.spawn_sequence == 0 or current_object.spawn_sequence == global.number[2] then
      global.object[2] = current_object
      for each object with label "p66" do
         if global.object[2].shape_contains(current_object) then
            current_object.delete()
         end
      end
   end
end

-- delete all dropped frags (coz most flood drop 1).
-- delete target locators too because if you resurrect in an object which kills you then your drop a target locator.       -- WARNING target locator might delete out of your hands.
-- "no_team" doesn't work. we can try guess the team of dropped frags.
for each object do
   --if current_object.is_of_type(frag_grenade) or current_object.is_of_type(target_locator) and current_object.team != neutral_team then    -- and current_object.team != neutral_team then
   if current_object.is_of_type(frag_grenade) and current_object.team != neutral_team then 
      current_object.delete()
      --current_object.set_waypoint_visibility(everyone)
   end
end


-- delete all dropped frags (coz most flood drop 1).     check this works.
-- "no_team" doesn't work. we can try guess the team of dropped frags.
--for each object do
   --if current_object.is_of_type(frag_grenade) and current_object.team != neutral_team and current_object.team != no_team then    -- and current_object.team != neutral_team then
      --current_object.delete()
   --end
--end

-- Count parasites. Delete furthest from objective and closest host combined.
--global.number[8] = 0

--function parasite_purge()
   --if global.number[8] > 100 then
   if global.team[0].number[5] > script_option[4] then
      global.object[9] = no_object
      for each object with label "p66" do
         if current_object.number[1] > global.object[9].number[1] or global.object[9] == no_object or current_object.is_out_of_bounds() and current_object.object[2] == no_object then    -- final condition: thralls immune.
            global.object[9] = current_object
         end
      end
      --global.object[8] = global.object[9].place_at_me(light_red, none,none, 0,0,0,none)
      --global.object[8] = global.object[9].place_at_me(hill_marker, none,none, 0,0,0,none)
      --global.object[8].set_waypoint_visibility(everyone)
      --game.show_message_to(all_players, none, "inv_gates")
      --global.object[9].object[3].delete()
      global.object[9].delete()
      --global.number[8] -= 1
      global.team[0].number[5] -= 1
      
      --parasite_purge()         -- luxury. you can just let it do deletions over a series of ticks instead of all in a single tick. Saves two actions this way.
   end
--end




------------------------ My object loop corpse syncing v1

----- Needs to work for (at least):
-- all dead survivor bodies
-- writhing survivor body, unpossessed
-- writhing posssessed survivor body
-- ballooning carriers
-- NPC spartan corpses (if I add them)
----- Needs to NOT work for hidden bodies (probably):


alias host_position = object.object[3]
--declare player.host_position with network priority high

------ corpse syncing set up: for important biped classes, make bomb and nest each as object.object[3]
for each object do
   -- 2nd last condition to limit scripted object by not making needless corpse sync bombs for combat form spartans.
   -- last condition is to avoid making corpse bomb for hidden bodies.
   --if current_object.number[7] == carrier_ID or current_object.is_of_type(spartan) and not current_object.number[7] == combat_ID and current_object.number[7] >= 0 then
   --
   -- hoping this includes carriers, survivors, and NPCs but doesn't include any other bipeds (also not stalkerpod).
   -- You can test which classes it works for by walking through shallow water in blood gulch as host. makes loads of splashing as host
   if current_object.number[7] == carrier_ID or current_object.is_of_type(spartan) and current_object.number[7] >= 0 and not current_object.number[7] > 4  then
      --current_object.copy_rotation_from(current_object, false)          -- test sink prevent
      if current_object.object[3] == no_object then
         current_object.object[3] = current_object.place_at_me(bomb, none, none, 0,0,0, none) -- this may not need to be a bomb, it might work as a phased object
         global.object[8] = current_object.object[3]
         global.object[8].object[3] = current_object         -- nest backwards too, so bomb can be deleted when biped garbage collects.
         global.object[8].number[7] = 4444                     -- bomb ID
         global.object[8].number[6] = -1                     -- mtest     re-add
         global.object[8].set_invincibility(1)     -- luxury semi-redudant.    explodes sometimes after round end but never explodes mid round in practice... unless corpse glicthing through floor very rare or falls long distance
         --global.object[8].set_waypoint_visibility(everyone)     -- singleplayer testing
      end
   end
end

------------ alternate set up. I think this is more condition efficient and less vague, BUT more action-expensive.
------ corpse syncing set up: for important biped classes, make bomb and nest each as object.object[3]
--function corpse_sync_setup()
   --if current_object.object[3] == no_object then
      --current_object.object[3] = current_object.place_at_me(bomb, none, none, 0,0,0, none) -- this may not need to be a bomb, it might work as a phased object
      --global.object[8] = current_object.object[3]
      --global.object[8].object[3] = current_object         -- nest backwards too, so bomb can be deleted when biped garbage collects.
      --global.object[8].number[7] = 4444                     -- bomb ID
         --global.object[8].number[6] = 1                     -- mtest     re-add
   --end
--end
------ carrier setup
--for each object do
   --if current_object.number[7] == carrier_ID then
      --corpse_sync_setup()
   --end
--end
-- survivor and NPC setup
--for each object do
   --if current_object.is_of_type(spartan) and current_object.number[7] == 0 then
      --corpse_sync_setup()
   --end
--end

----- corpse syncing host maintenance: constantly attach bomb to body (alive or not) 
for each object do
   if current_object.number[7] == 4444 then
      current_object.set_pickup_permissions(no_one)
      -- move our object to where the host sees it
      global.number[10] = current_object.get_distance_to(current_object.object[3])
      if global.number[10] > 3 then          -- condition added back, v7.7 CGB.     attempted corpse bomb corpse sync fix.       increased to 3, to account for the '1 up' increase below.
        current_object.attach_to(current_object.object[3], 0,0,1,absolute)       -- v7.7 changed to attach 1 up, so that it doesn't ever fall through ground.
        current_object.detach()
      end
      --current_object.copy_rotation_from(current_object.object[3], true)      -- redundant? v23   I think I added this, not Gamergotten, and I think it's pointless or even harmful if it twist bomb.
   end
end

------------- my object loop version of corpse syncing.
--on local: do
   --if host_indicator == 0 then -- do this so we dont attempt to correct bipeds on host (they're already correct)
   --end
--end

-- detach elite, copy_rotate, attach every tick.

-- needs a lasting variable (lasting on local for clients anwyay) to show widget info correctly.
-- Note: this variable can be used for other things outside local.
-- Note: global.object[12] is currently unused for anythign else so it's valuable. If needed, you could use a less important one here like global.object[5] so long as [5] isn't use elsewhere on local
-- Note: if you DO use this lasting variable outside of "on local" then widgets will look wrong for HOST in PRIVATE matches, but will be fine for clients and on CGB 
alias local_current_biped = global.object[12]       

on local: do
         -- Stalker form horizontal elite biped       -- cheap version. might not be right rotation on client.

--- guardian monitor spartan laser scaling (v1)				-- untested. longer than v2.
   --for each player do
      --if current_player.biped.is_of_type(monitor) then
	     --for each object do
		    --current_object.get_distance_to(current_player.biped)
			--if global.number[10] == 0 and current_object.is_of_type(spartan_laser) then
			   --current_object.set_scale(1)
			   --current_object.copy_rotation_from(current_object, true)
			--end
         --end
	  --end
   --end
--- guardian monitor spartan laser scaling (v2)				-- works great!
   --for each object do
      --if current_object.is_of_type(spartan_laser) then
	      --global.player[4] = current_object.try_get_carrier()
		   --if global.player[4].biped.is_of_type(monitor) then
			   --current_object.set_scale(1)
			   --current_object.copy_rotation_from(current_object, true)
         --end
	   --end
   --end
--- hide ranger weapons.         -- might be a better way to do this but I'm not sure.
   --for each object do
      --if current_object.is_of_type
   for each player do
      global.object[2] = current_player.biped
      global.object[13] = current_player.try_get_vehicle()
      
      -- Survivor held chewing parasite full size.       See if it looks good.      Note this also affects awakened parasite players, so their resize further below is semi-redundant.
      global.object[6] = current_player.try_get_weapon(primary)
      if global.object[6].is_of_type(skull) then
         global.object[6].set_scale(200)
      end
      
      -- swarm form
      --if global.object[6].is_of_type(covenant_power_core) then
         --global.object[6].set_scale(1)
      --end
-----------------------------------
---------- LOCAL RESCALING --------
-----------------------------------
      -- if global.object[2].team == team[1] then      -- haven't tested this, but if it works then this combines the following two conditions into one.
      if current_player.team == team[1] and global.object[2] != no_object then       -- both are luxury redundant condition. kinda just here to reduce lag. improve performance.
         for each object do
            global.number[10] = current_object.get_distance_to(current_player.biped)
            if global.number[10] == 0 then
               if current_object.is_of_type(needle_rifle) or current_object.is_of_type(spiker) or current_object.is_of_type(gravity_hammer) and global.object[2].number[7] != combat_ID and global.object[2].number[7] != reanimating_ID then      -- global.object[2].number[7] == 19 and
                  current_object.set_scale(1)
                  --current_object.set_hidden(1)
                  current_object.number[7] = 4400
                  --current_object.set_pickup_permissions(no_one)      -- not sure... surely I'd have done this already somewhere else in the script?
               end
               -- might be possible to do this cheaper, like with number[6] or something.    redundancy.
               --if global.object[2].number[7] == 5 or global.object[2].number[7] == 19 then
                  if current_object.is_of_type(active_camo_aa) then
                     current_object.set_scale(1)
                  end
                  if current_object.is_of_type(energy_sword) then     -- and global.object[2].number[7] == 5 then
                     current_object.detach()
                     current_object.set_scale(1)
                     current_object.number[7] = 4400
                     --current_object.set_pickup_permissions(no_one)
                     --current_object.team = team[1]      -- blue team swords are marked for deletion. other team sword can be placed in forge.
                  end
               --end
               if global.object[2].number[7] == 26 or global.object[2].number[7] == 33 then     -- swarm form.       no covenant_power_core removed (2nd condition).
                  -- I could probably resize the attached skull cheaper by scaling on creation. It works for carrier and combat so should work for awakened parasite too. redundancy.
                  --if current_object.is_of_type(skull) then
                     --current_object.set_scale(200)
                  --end
                  -- hide knife.    -- oh wait actually this could resize floor objects the player walks over. hmm maybe not worth it then.
                  -- last 2 conditions are for swarm form. without them, thralls which attach-detach to the player by leash can sometimes scale down their hitbox (or the hill_marker middleman, causing hitbox to get out of line)
                  if not current_object.is_of_type(skull) and not current_object.is_of_type(spartan) and not current_object.is_of_type(elite) and global.object[13] == no_object and not current_object.is_of_type(fusion_coil) and not current_object.is_of_type(hill_marker) then -- and not current_object.is_of_type(oni_van) then
                     current_object.set_scale(1)
                     
                     alias spore_cloud = object.object[2]
                     if global.object[2].number[7] == 33 and not global.object[2].spore_cloud.is_of_type(oni_van) and host_indicator == local_ID then
                        global.object[2].spore_cloud = global.object[2].place_at_me(oni_van, none, none, 0, 0, 2, none)
                        global.object[2].spore_cloud.health = 49             -- 74% warthog or 49% warthog or 49% mongoose are all good options for types of smoke without fire.
                        --global.object[2].spore_cloud.kill(false)
                        --global.object[2].spore_cloud.set_scale(50)
                        --global.object[2].spore_cloud.number[6] = 1
                        --global.object[8].set_scale(1)
                        -- damage update (necessary)
                        global.object[8] = global.object[2].spore_cloud.place_between_me_and(global.object[2].spore_cloud, plasma_cannon, 0)
                        global.object[8].kill(false)
                        --global.object[3].object[1].attach_to(global.object[3], 120,0,0,relative)         -- when finished testing, change attach location to centre on biped.
                        for each object do
                           if current_object.is_of_type(detached_plasma_cannon) or current_object.is_of_type(plasma_cannon) then
                              global.number[8] = current_object.get_distance_to(global.object[2].spore_cloud)
                              if global.number[8] < 15 then       -- 15 seemed too low in CGB, sometime tu
                                 current_object.delete()
                              end
                           end
                        end
                        --global.object[2].spore_cloud.attach_to(global.object[3], 20,0,-1,relative)        -- singleplayer testing
                        global.object[2].spore_cloud.attach_to(global.object[2], 0,0,-1,relative)
                     end
                  end
               end
            end
         end
      end
   end
---------------------------------
   -- Parasite counting
   global.team[0].number[5] = 0
   global.team[0].number[4] = 0
   -- count parasites, apply to waypoint
   for each object with label "p66" do
      --global.number[8] += 1
      --global.team[0].number[5] = global.number[8]        -- pseudo global number for waypoint.
      global.team[0].number[5] += 1                       -- pseudo global number for waypoint.
      -- doing this on local just so I can use a team pseudoglobal number for instead of eating a player.number for it.
      if current_object.player[0] == the_local_player then     -- and current_object.player[0] != no_player  then   
         global.team[0].number[4] += 1
      end
   end

----- invis sword & deletion (brute style)         also handled power core here.
-- removed. see flood snippets with above title.

   
--script_widget[1].set_text("Your parasites: %nr/nTotal parasites: %n", global.team[0].number[4], global.team[0].number[5])
--script_widget[1].set_visibility(global.team[0])

   -- /////////////////////////////////
   -- // LOCAL PLAYER FINDING SCRIPT //
   -- /////////////////////////////////
   -- look in snippets for "the_local_player finder from v15" to find the most up to date version before I removed host searching entirely.
   -- Remember to also re-add "global.timer[3].set_rate(-100%)" at the start of the script. that's the host_existance_check.

alias machine_type = host_indicator
alias client = the_local_player
alias dummy_ID = -5
alias obj_ID = object.number[7]
alias clientside_weapon = player.local_test_obj

   if host_indicator == local_ID then      -- or not host_existance_check.is_zero() then 
      for each object do
         if current_object.obj_ID == dummy_ID then
            current_object.delete()
         end
      end
      for each player do
         -- spawn and postion a crosshair triggering target
         -- removed for space. ideally re-add.
         global.object[13] = current_player.try_get_vehicle()     -- to delay searching for local biped until players exit vehicles, so that sierra pelican starts don't look shit.
         if the_local_player == no_player and global.object[13] == no_object then       --and global.object[13] == no_object then
            alias dummy = global.object[8]
                --dummy = current_player.biped.place_at_me(monitor, "dummy", suppress_effect, 0, 0, 0, none)
            dummy = current_player.biped.place_at_me(monitor, none, suppress_effect, 0, 0, 0, none)
            global.object[2] = current_player.biped
            if global.object[2].number[7] != 19 and global.object[2].number[7] != 26 and not global.object[2].is_of_type(monitor) then
               --dummy.attach_to(current_player.biped, 10, 0, 0, relative)
               dummy.attach_to(current_player.biped, 7, 0, 6, relative)
            end
            if global.object[2].number[7] == 19 or global.object[2].number[7] == 26 or global.object[2].is_of_type(monitor) then
               --dummy.attach_to(current_player.biped, 10, 0, -5, relative)
               dummy.attach_to(current_player.biped, 7, 0, 0, relative)
            end
            dummy.detach() -- detach so player can see the bipod; player cant see it if its attached to them
            --dummy.set_scale(180)
            dummy.set_scale(300)
            dummy.obj_ID = dummy_ID

            -- OPTIONAL:  If your gametype allows some players to spawn with no wepaon, then we need to create a temporary clientside weapon to allow get_crosshair_target to function.
            alias temp_weapon = global.object[6]
            temp_weapon = current_player.try_get_weapon(primary)
            if temp_weapon == no_object then
            -- nest the clientside weapon under the player so we can delete it later.
               --temp_obj1 = dummy
               current_player.add_weapon(current_player.clientside_weapon)
               if current_player.clientside_weapon == no_object then
                  current_player.clientside_weapon = current_player.biped.place_at_me(plasma_rifle, none,none,0,0,0,none)
                  --temp_obj6 = current_player.clientside_weapon
                  --temp_obj6.obj_ID = -6
               end
            end

            alias get = temp_obj0
            get = current_player.get_crosshair_target()
            if get != no_object then
               the_local_player = current_player
            end
         end
      end
      --if client != no_player then
   end      -- redudndancy here. you could include next local player stuff under the above block since host doesn't run that.

   if the_local_player != no_player then 
         -- This one isn't watertight. doesn't delete plasma rifles dropped by quitting players, which can maybe be picked up by the local player (not sure if host allows that or not).
         for each player do
            --primary_weapon = current_player.try_get_weapon(primary)
            --if primary_weapon == current_player.clientside_weapon then
               current_player.clientside_weapon.delete()
            --end
         end
      
      -- Flood singelplayer toggle.    -- elite testing
      if host_indicator == local_ID then               -- SINGLEPLAYER TESTING (switched to 1). stest. needs to be changed back to 0 in end.
         -- corpse syncing
         for each object do
            if current_object.is_of_type(spartan) or current_object.is_of_type(elite) and current_object.object[3].is_of_type(bomb) then
               --current_object.host_position.set_scale(1)        -- I'm using number[6].
               --current_object.host_position.copy_rotation_from(current_object.host_position, true)       -- nope this hasn't fixed sinking. > NOT REDUNDANT. necessary TO PREVENT BOMB SINKING INTO FLOOR IF BIPED PHYSICS SLEEP.
               global.number[8] = current_object.health -- only do biped corrections when player "is_dead", you will need to write a script to set this yourself
               if global.number[8] == 0 then
                  -- do a distance check to see if the bipeds position needs updating, this is so we dont contiunously attach/detach them into the ground, causing the body to stretch
                  global.number[8] = current_object.host_position.get_distance_to(current_object)
                  --if global.number[8] > 5 then
                  if global.number[8] > 6 then        -- v7.7 increased distance strictness, hoping to make corpses less glitchy.
                     -- attach corpse to host bomb, assigning approx position and velocity from the host corpse.
                     current_object.attach_to(current_object.host_position, 0,0,0, relative)
                     current_object.detach()
                  end
               end
            end
         end
         -- Stalkerpod client rotation (needed to be horizontal)
         -- this sometimes doesn't work. Can't tell why. It's maybe worse on certain maps? H3 control room especially.
         for each object do
            -- 2nd condition is an attempt to fix it sometimes not rotating for clients.   object.number[2] is high priority, object.object[0] is low, so maybe it's trying to rotate before knowing the stalkerpod exists.
            if current_object.number[7] == 19 and current_object.object[0] != no_object then          
               if current_object.number[2] == 0 then     -- and current_object.object[0].is_of_type(elite) and current_object.object[1].is_of_type(sound_emitter_alarm_2) then      -- failsafe conditions
                  current_object.number[2] = 1
                  current_object.object[0].detach()      -- elite should be upright
                  global.object[8] = current_object.object[0].place_at_me(sound_emitter_alarm_2, none,none,0,0,0,none)     -- make a normal flat object to attach to.
                  current_object.object[0].attach_to(global.object[8], 0,0,0,relative)       -- attach elite. should be same orientation (for client)
                  global.object[8].copy_rotation_from(current_object.object[1], true)        -- copy from the host block (upright)
                  global.object[8].attach_to(current_object.object[1], 0,0,0,relative)       -- attach to it.
                  --global.object[8] = current_object.place_at_me(light_red, none,none,0,0,20,none)        -- finalpass.
               end
            end
         end
-------------------------
---- LOCAL WIDGETS ------
-------------------------
         --global.object[2] = the_local_player.biped
         local_current_biped = the_local_player.biped
         
         -- flashlights
         for each object with label "Flashlights" do
            if current_object.is_of_type(fx_purple) then
            --current_object.attach_to(client_master, 0,0,0,relative)         -- hide FX particles
            --if current_object.object[2] == no_object then
               --current_object.object[2] = current_object.place_at_me(fx_purple, none, none, 0,0,0,none)
               --global.object[13] = the_local_player.try_get_vehicle()
               global.object[6] = the_local_player.try_get_weapon(primary)
               if global.object[6] == no_object then
                  global.object[6] = local_current_biped
               end
               current_object.object[1].detach()
               current_object.object[1].copy_rotation_from(global.object[6], true)
               current_object.object[1].attach_to(global.object[6], 0, 0, 2, relative)
               --current_object.object[1].copy_rotation_from(local_current_biped, true)
               for each object do
                  if current_object.is_of_type(light_white) and current_object.team == no_team then
                     current_object.set_scale(1)
                  end
               end
               
               --if global.object[6] == no_object or global.object[13] != no_object then            -- global.object[6].is_of_type(detached_machine_gun_turret) or global.object[6].is_of_type(detached_plasma_cannon)
                  --current_object.set_scale(1)
                  --current_object.object[1].copy_rotation_from(local_current_biped, true)
                  --current_object.object[1].attach_to(local_current_biped, 0,0,6, relative)
               --end
 


               current_object.object[1].attach_to(local_current_biped, 0, 0, 6, relative)
              if the_local_player.team == team[0] and current_object.object[1] == no_object then
                  current_object.object[0] = current_object.place_at_me(fx_juicy, none, none, 0,0,0,none)

                  current_object.object[1] = current_object.place_at_me(sound_emitter_alarm_2, none, none, 0,0,0,none)
                  global.object[8] = current_object.place_at_me(light_white, none, none, 0,0,0,none)
                  global.object[8].attach_to(current_object.object[1], 50, 0, 0, relative)
                  --global.object[8] = current_object.place_at_me(light_white, none, none, 0,0,0,none)
                  --global.object[8].attach_to(current_object.object[1], 50, 0, 0, relative)
                  global.object[8] = current_object.place_at_me(light_white, none, none, 0,0,0,none)
                  global.object[8].attach_to(current_object.object[1], 30, 0, 0, relative)
                  global.object[8] = current_object.place_at_me(light_white, none, none, 0,0,0,none)
                  global.object[8].attach_to(current_object.object[1], 5, 0, 0, relative)
                  global.object[8] = current_object.place_at_me(light_white, none, none, 0,0,0,none)
                  global.object[8].attach_to(current_object.object[1], 15, 0, 0, relative)
                  --global.object[8] = current_object.place_at_me(light_white, none, none, 0,0,0,none)
                  --global.object[8].attach_to(current_object.object[1], 75, 0, 0, relative)
                 -- global.object[8] = current_object.place_at_me(light_white, none, none, 0,0,0,none)
                  --global.object[8].attach_to(current_object.object[1], 100, 0, 0, relative)
--function flashlight_beam_setup()
   --global.object[8] = current_object.place_at_me(light_white, none, none, 0,0,0,none)
   --global.object[8].attach_to(current_object.object[1], 0, 0, 0, relative)
--end                  
                  --current_object.object[1] = current_object.place_at_me(light_white, none, none, 0,0,0,none)
                  --current_object.object[1].set_scale(1)
                  --current_object.object[1].attach_to(local_current_biped, 25, 0, 4, relative)
                  --current_object.object[1] = current_object.place_at_me(fx_orange, none, none, 0,0,0,none)
               end
            --end
            if the_local_player.team != team[0] then
               --global.object[8] = client_master.place_at_me(fx_purple, none, none, 0,0,0,none)
               --if not current_object.is_of_type(light_white) then
                  current_object.object[0].delete()
                  current_object.object[1].delete()
               --end
            end
            end
         end
         --
         
         script_widget[0].set_visibility(the_local_player, false)
         script_widget[1].set_visibility(the_local_player, false)
         script_widget[2].set_visibility(the_local_player, false)
         if the_local_player.team != team[1] then                         -- plan B, try this.
            script_widget[3].set_visibility(the_local_player, false)        -- testing. need to hide this widget on round restart. could try putting it in the local player finder section.
         end
         --game.show_message_to(global.player[5], none, "inv_vehicle")
         if the_local_player.team == team[1] then
            -- indent to avoid frag grenade widget
            script_widget[0].set_text("             Your parasites: %n\n             Total parasites: %n", global.team[0].number[4], global.team[0].number[5])
            script_widget[0].set_visibility(the_local_player, true)
            script_widget[1].set_visibility(the_local_player, true)
            script_widget[2].set_visibility(the_local_player, true)
            --script_widget[1].set_meter_params(none)
            script_widget[1].set_meter_params(timer, local_current_biped.timer[3])
            script_widget[1].set_icon(infection)
         end
         if local_current_biped.number[7] == 4 then
            --script_widget[2].set_text("Frag = Spawn & throw parasite\r\nAbility = Explode")
            --script_widget[2].set_text("Frag = Spawn & throw parasite\nAbility = Explode")
            script_widget[2].set_text("Frag = Vomit parasites\nAbility = Explode")
            script_widget[1].set_text("Carrier Form")
            script_widget[1].set_icon(assault)
            script_widget[3].set_visibility(the_local_player, true)
            script_widget[3].set_text("Incubating brood...")
            script_widget[3].set_meter_params(number, local_current_biped.incubation, incubation_ready)
            if local_current_biped.incubation >= incubation_ready then
               script_widget[3].set_visibility(the_local_player, false)
            end
         end
         if local_current_biped.number[7] == 5 then
            script_widget[2].set_text("Frag = Leap\nAbility = Eject")
            script_widget[1].set_text("Combat Form")
            script_widget[1].set_icon(slayer)
         end
         if local_current_biped.number[7] == 19 then
            script_widget[2].set_text("Frag = Leap\nAbility = Transform + Heal")
            --script_widget[1].set_text("Stalker-Ranger Form")
            script_widget[1].set_text("Stalker Form")
            script_widget[1].set_icon(invasion_slayer)

         end
         if local_current_biped.number[7] == 26 then
            --script_widget[2].set_text("Frag = Leap\nAssimilate a human    ")
            script_widget[2].set_text("Frag = Leap\nMelee = Assimilate a fresh host")
            --script_widget[1].set_text("Awakened Parasite")
            script_widget[1].set_text("Infection Form")
         end
         if local_current_biped.number[7] == 110 then
            script_widget[2].set_text("Mutating and Reanimating...")
            script_widget[1].set_meter_params(number, local_current_biped.number[5], 240)
            script_widget[1].set_text("Fresh Biomass!")
            --script_widget[1].set_icon(oddball)
         end
         -- swarm form
         if local_current_biped.number[7] == 33 or local_current_biped.number[7] == juggernaut_ID then
             

         
            alias thrall_count = object.number[4]
            --alias thrall_max = object.number[3]
            alias thrall_max = team[0].number[3]
            --script_widget[2].set_value_text("New member every 3 sec\r\nCurrent size = %n/10", global.object[2].thrall_count)        
            -- Damn. global.object[2] getting reassigned later on local will change this widget number. need to either nest as a player number and use hud_player, or use a permanent variable.
            
            -- redundancy here. if you changed "global.object[2] = the_local_player.biped" to a lasting variable (lasting on local), you can skip the following two lines.
            --client_master.number[2] = global.object[2].thrall_count
            --client_master.number[3] = global.object[2].thrall_max
            --script_widget[2].set_text("New member every 3 sec\r\nSwarm size = %n/%n", client_master.number[2], client_master.number[3])
            --script_widget[2].set_text("Direct a regenerating horde\nSwarm size = %n/%n", client_master.number[2], client_master.number[3])             
            --script_widget[2].set_text("Direct a regenerating clutch of the Gravemind's children\r\nSwarm size = %n/%n", client_master.number[2], client_master.number[3])         
            --script_widget[2].set_text("Direct the Gravemind's children\r\nSwarm size = %n/%n", client_master.number[2], client_master.number[3])         
            --script_widget[2].set_text("Direct a regenerating clutch of the Gravemind's children\r\nSwarm size = %n/%n", client_master.number[2], client_master.number[3])  
            --script_widget[2].set_text("Direct a swirl of parasites\r\nSwarm size regenerates: %n/%n", local_current_biped.thrall_count, local_current_biped.thrall_max)
            
            --This one was good before i had to add ejection/disband.
            --script_widget[2].set_text("Direct the Gravemind's children\r\nSwarm size regenerates: %n/%n", local_current_biped.thrall_count, local_current_biped.thrall_max)
            --
            
            --script_widget[2].set_text("Direct the Gravemind's children\r\nSwarm grows   Ability = Disband")
            --script_widget[2].set_text("Direct the Gravemind's children\n     Ability = Disband")
            --script_widget[2].set_text("Direct the Gravemind's children\nFrag = Throw parasite     Ability = Disband")
            --script_widget[2].set_text("Direct the Gravemind's children\nFrag = Hurl parasite     Ability = Disband")


               -- Juggernaut widgets. removed for total file space. 
               --script_widget[1].set_icon(koth)
               --script_widget[2].set_text("        Direct the Gravemind's children\n        Frag = Hurl blister bomb")
               --script_widget[1].set_text("Flood      Juggenaut\n      Swarm %n/%n",local_current_biped.thrall_count, 20)
               script_widget[1].set_meter_params(number, local_current_biped.thrall_count, 20)

            
            script_widget[2].set_text("        Direct the Gravemind's children\nFrag = Hurl parasites     Ability = Disband")
            script_widget[1].set_text("Swarm      Form  \n      Size %n/%n",local_current_biped.thrall_count, team[0].number[3])
            script_widget[3].set_visibility(the_local_player, false)
            
            if local_current_biped.number[7] == 33 then
               -- spore cloud: hide swarm form biped and make taller for better view. This makes the spore cloud invisible but that's okay for 1st person.
               script_widget[1].set_icon(territories)
               local_current_biped.set_hidden(true)
               local_current_biped.set_scale(20)
               script_widget[1].set_meter_params(number, local_current_biped.thrall_count, team[0].number[3])



            end
         end
            -- thruster limit
            -- this will probably need to be done on local to work.
         if local_current_biped.is_of_type(monitor) then
            global.number[10] = local_current_biped.get_speed()
            --if global.number[10] > 65 then         -- 45 allows every diagonal movement subboost.
            if global.number[10] > 55 then         -- 45 allows every diagonal movement subboost.
               global.object[8] = local_current_biped.place_between_me_and(local_current_biped, flag_stand, 0)
               local_current_biped.attach_to(global.object[8], 0,0,0,relative)
               local_current_biped.detach()
               global.object[8].delete()
            end
         end
         
         
         --if global.object[2]number[4] == -1 then
            --script_widget[3].set_text("Ability = Transform to RANGER")
            --script_widget[3].set_visibility(the_local_player, true)
         --end
         --if global.object[2]number[4] == -1 then
            --script_widget[3].set_text("Ability = Transform to STALKER")
            --script_widget[3].set_visibility(the_local_player, true)
         --end
         
         -- WARNING I don't remember what this is for, but I'm 99% sure it shouldn't be here nested under client-only code. This will probably cause crashes/crashing.
         -----> ohhhhhh no nvm. this is just cealning up the the_local_player finding clientside biped :)
         --for each object do
	         --if current_object.is_of_type(spartan) and current_object.number[2] == 770 then
               --current_object.delete()
               --global.player[5].biped.place_at_me(light_green, none,none,0,0,0,none)
	         --end
         --end
         -----> changed to current_player.local_test_obj  (moved higher up)
         -----> changed to current_player.local_test_obj.
         
         -- local widgets
         -- cut
         --script_widget[2].set_visibility(the_local_player, false)		-- class name
         --global.object[2] = the_local_player.biped 
         --script_widget[2].set_text("")
         --script_widget[2].set_visibility(the_local_player, true)
         --if the_local_player.team == team[1] and the_local_player.biped != no_object and global.number[2] > 1 then
            --script_widget[2].set_text("Super Mutant")
         --end
         --if global.object[2].number[0] == 17 then
            --script_widget[2].set_text("Deathclaw (apex predator)")
         --end
         --if global.object[2].number[0] == 9 then
            --script_widget[2].set_text("Feral Ghoul: your radioactive aura slows humans!")
         --end
         
         -----------------------
         -- AI CLIENT HANDLING--
         -----------------------
         alias client_master = global.object[15]         -- Lasting. For clients anyway.
         
         -- hide AI movement blocks ONLY if local player is infected. This is because it turns out the 1x1 flats are great for disrupting survivor vehicle movement.
         -- now deletes same tick, shouldn't be needed. commented out.
         --for each object do
            --if global.player[5].team != team[0] and current_object.is_of_type(block_1x1_flat) and current_object.team == no_team and current_object != client_master.object[1] then
               --current_object.attach_to(client_master, 0,0,0,relative)
            --end
         --end
         
         -- Push parasite holding survivors upwards
         -- moved out of the_local_player. 
         -- Not sure, but I suspect host AND client will both need to push_upward to make it work, same as attach-detach teleporting players.
         -- Push parasited survivors upwards to give them a possessed/struggle feel. I serendipitously discovered that the parasite's natural push upwards is great when attacked,
         -- but this will only work for host unless I recreate the effect here.
         --global.object[6] = global.player[5].try_get_weapon(primary)
         --if global.object[6].is_of_type(skull) then
         --if global.object[6].is_of_type(skull) then             -- re-add change to skull when finished. singleplayer
            --global.number[10] = global.player[5].biped.get_speed()
	         --if global.number[10] < 3 then
               --global.player[5].biped.push_upward()
            --end
         --end
         -------------------
         -- WALL CLIMBING --
         -------------------

         alias client_master = global.object[15]         -- Lasting. For clients anyway.
         alias wall_climb_master = global.object[9]
         alias test_obj = global.object[8]
		   global.number[7] = global.number[6]
		   global.number[7] %= 15                    -- four times a tick


      
         --for each player do
            --current_player.frag_grenades = 4    -- stesting
            --if current_player == the_local_player then
               --script_widget[3].set_visibility(current_player, false)
               --global.object[2] = current_player.biped
               global.object[5] = the_local_player.try_get_armor_ability()
 
         if client_master == no_object then
            --client_master = local_current_biped.place_at_me(hill_marker, none,none,0,0,0,none)               -- clientside master hill marker
            -- in v23 I somehow made a bug where the wall climbing grid has collision 4 times a sec at client master location, so I'll simply spawn the client_master out the map at the master hill_marker.
            client_master = global.object[4].place_at_me(hill_marker, none,none,0,0,0,none)        
            
            --client_master.object[0] = the_local_player.biped.place_at_me(block_1x1_flat, none,none,0,0,0,none)  -- client's cling floor
            --client_master.object[1] = the_local_player.biped.place_at_me(block_1x1_flat, none,none,0,0,0,none)  -- client's cling floor
            client_master.object[1] = local_current_biped.place_at_me(grid, none,none,0,0,0,none)  -- client's cling floor
            --client_master.object[1].set_scale(1)
            client_master.object[1].set_hidden(true)
            --global.object[10] = client_master.object[1]
            --global.object[10].number[6] = 1
            client_master.object[3] = local_current_biped.place_at_me(hill_marker, none,none,0,0,0,none)    -- delegate for wall climbing objects. might not need this delegate when mod is finished.
            wall_climb_master = client_master.object[3]
            wall_climb_master.object[0] = local_current_biped.place_at_me(hill_marker, none, none, 0,0,0, none)
            wall_climb_master.object[1] = local_current_biped.place_at_me(hill_marker, none, none, 0,0,0, none)
         end 

               wall_climb_master = client_master.object[3]
               alias spinner = wall_climb_master.object[0]
               alias extremity = wall_climb_master.object[1]
               
               wall_climb_master.number[1] /= 2
               --client_master.object[1].set_scale(1)


               -- class criteria
               if not local_current_biped.number[7] == 5 and not local_current_biped.number[7] == 19 and not local_current_biped.number[7] == 26 then 
                  client_master.object[1].attach_to(client_master, 0,0,0,relative)
                  global.number[7] = 1
               end
               
                 -- only happens when remained is 0, meaning it has to be exact factor ot the %= operator.
               --   WARNING you should probably add a 3rd local negative feedback condition to prevent multiple wall checks in first 10 ticks after toggle.
-- or global.object[5].number[4] > 0   <-- second condition is to attempt a quick wall cling right after activatin ability.   <-- Now all local crouch, so no host aa toggle handling so no fast signal needed!
               if global.number[7] == 0 and wall_climb_master.number[1] < 2 then    
                  
                  -- 5 tick refractory period (I think).  to stop every-tick wall checks each time toggle gtes used, while still allowing fastest possible first check when it does.
                  --if global.object[5].number[4] > 0 then
                     --wall_climb_master.number[1] = 20
                  --end

----- crouch instead of aa toggle
-- + script cheaper
-- + all local (so probably more immediate)
-- + crouch is intuitive to go down
-- + no AA defeaning
-- + AA free for use, or as a different input
-- - Some reason, turning off by crouch leaves you floating till you move. turning off by AA doesn't do this.



-- crouch check v2 optimised
      --if the_local_player.biped != no_object then
                  global.number[10] = 0
                  global.object[8] = the_local_player.biped.place_at_me(hill_marker, none, none, 0, 0, 1, none)
                  global.object[8].attach_to(the_local_player.biped, 0,0,1,relative)     -- probs redundant   -- not 100% sure, but I have a hunch this is faster to react.
                  global.object[8].detach()                                            -- probs redundant
                  global.number[10] = the_local_player.biped.get_distance_to(global.object[8])
                  global.object[8].delete()
                  if the_local_player.biped.is_of_type(elite) then
                     global.number[10] -= 1
                  end
      --end
   --end
--end
                  -- anti-climbing
                  for each object with label "no_climb" do
                     if current_object.shape_contains(local_current_biped) then
                        global.number[10] = 0
                     end
                  end
                  
                  
                  -- wall climbing inactive
                  --if local_current_biped.number[4] != 6 then            -- inefficient. It's trying to attach twice a sec all game long.                  
                  -- Player is crouching
                  --if global.number[10] < 2 then     -- this also occurs when biped is dead.
                  if global.number[10] != 2 then
                     script_widget[3].set_visibility(the_local_player, false)
                     client_master.object[1].attach_to(client_master, 0,0,0,relative)
                     --local_current_biped.copy_rotation_from(local_current_biped, false)         
                  -- wake physics. Not sure if this will work. Only needed for crouch version for some reason   --> turns out activating aa wakes your physics. probably to stop middair armor lock.
                     -- do a speed test and bump the spartan if 0 to wake physics
                     global.number[8] = local_current_biped.get_speed()
                     if global.number[8] == 0 then
                        global.object[8] = the_local_player.biped.place_between_me_and(the_local_player.biped, monitor, 0)        -- bomb doesn't work.
                        global.object[8].delete()
                     end
                     --game.show_message_to(all_players, none, "%n", global.object[2].number[4])
                  end
                  
                  -- wall climbing active
                  --if local_current_biped.number[4] == 6 then
                  -- player isn't crouching
                  if global.number[10] == 2 then
                     script_widget[3].set_visibility(the_local_player, true)
                     script_widget[3].set_text("Climbing enabled!")              -- note that in Fallout mod, the host had to first set text before clients could see it or change it at all.
                     script_widget[3].set_meter_params(none)        -- if you wanted, you could use this for leap regen. but I think it's screen clutter.
                     --game.show_message_to(all_players, none, "inv_weapon")
                     client_master.object[1].detach()
                  -- waist check
                     spinner.attach_to(local_current_biped, 0, 0, 4, relative)
                     spinner.detach()
                     global.number[8] = 0
                     global.number[10] = 0
                     wall_proximity_check()
                     -- TROUBLESHOOTING SPINNER NODE MESSAGE. Use this like a compass bearing to know which direction you're clinging to.
                     --game.show_message_to(all_players, none, "%n", global.number[10])        -- if this number changes while you're standing still, then I'm doing too many iterations. subtract 1.
                  -- ceiling check
                     spinner.attach_to(local_current_biped, 0, 0, 8, relative)
                     spinner.detach()
                     spinner.set_scale(50)      -- so that 3 attach distance for extremity is much tighter around head
                     global.number[10] = 0
                     wall_proximity_check()
                     spinner.set_scale(100)      -- return to normal for next check
                  --                     
                     -- assume proximal wall
                     --client_master.object[1].attach_to(local_current_biped, 0,0,-1,relative)     -- 1x1 perfect platform place.
                     client_master.object[1].attach_to(local_current_biped, -50,0,0,relative)      -- using a grid now, attaching long way behind. Hoping this will be less visible than a 1x1.
                     client_master.object[1].detach()
                     -- if fail / no proximal wall
                     if global.number[8] == 0 then
                        client_master.object[1].attach_to(client_master, 0,0,0,relative)
                     end
                     
-- half adapated Gamgergotten script                     
                     --global.object[5] = global.object[2].place_at_me(hill_marker, none, none, 0,0,0, none)
                     --global.object[5].attach_to(global.object[2], 4, 0, 5, relative)
                     --global.object[5].detach()
                     ---global.object[8] = global.object[5].place_at_me(bomb, none, none, 0,0,0, none)
						   --global.number[10] = global.object[5].get_distance_to(global.object[8])
                     --if global.number[10] > 0 then -- our dude is facing a wall

-- Gamergotten's ggquarantine wall detection script.
						--global.object[2].number[1] = 0
						-- do wall check
						--if global.object[5] == no_object then
							--global.object[5] = global.object[2].place_at_me(hill_marker, none, none, 0,0,0, none)
						--end
                  --global.object[5].attach_to(global.object[2], 4, 0, 5, relative)
                  --global.object[5].detach()
                  --global.object[0] = global.object[5].place_at_me(bomb, none, none, 0,0,0, none)
						--global.number[1] = global.object[5].get_distance_to(global.object[0])
                  --if global.number[1] > 0 then -- our dude is facing a wall
							 -- give about 0.525 seconds future step delay
							--global.object[2].number[1] = -45
							-- zombie wall climbing logic
							--if global.object[2].number[6] == 2 then
								--global.object[2].number[1] = 0
								--global.object[2].push_upward()
							--end
                     -- potentially this will fix them going through walls
                     --global.number[1] = 0
                  --end
                  --if global.number[1] <= 0 then -- wall check failed, we're good to walk
						   --if global.object[1] == no_object then
				            --global.object[1] = global.object[2].place_at_me(hill_marker, none, none, 0,0,0, none)
				         --end    -- 3
                  end
               end
            end
         --end
	   --end
      -- /////////////////////////////////
      -- // LOCAL PLAYER CODE EXECUTION //
      -- /////////////////////////////////
      -- the_local_player is our local player, have fun
      -- note, this will run for each client (this includes the host)
   end
   -- here is the end of the_local_player only things.

   ----------
   -- LEAP -- 
   ----------
   local_leap()
   --the_local_player_leap()

-- Push parasite holding survivors upwards to give them a possessed/struggle feel. I serendipitously discovered that the parasite's natural push upwards is great when attacked,
-- but this will only work for host unless I recreate the effect here.
-- Might not to make this client only (global.obejct[4] == no_object) or even local player only.
   for each player do
      global.object[6] = current_player.try_get_weapon(primary)
      if global.object[6].has_forge_label("p66") and current_player.team == team[0] then       -- global.object[6].is_of_type(skull)
         --global.number[10] = current_player.biped.get_speed()
         global.number[7] = global.number[6]
         global.number[7] %= 30
	      if global.number[7] == 0 then         -- and global.number[10] < 3 
            global.object[8] = current_player.biped.place_at_me(monitor, none, suppress_effect, 0,0,0, none)
            global.object[8].set_shape(box, 50, 50, 2, 1)
            if not global.object[8].shape_contains(current_player.biped) then
               --global.object[8].attach_to(current_player.biped,0,0,0,relative)
               -- based on Warp Zealot
               --global.player[4].object[2] = current_object     -- leap attach target is grenade, for use on local.
               --global.object[2] = global.player[4].biped
               --global.object[2].timer[2] = 4
               --global.object[2].timer[2].set_rate(-1000%)
               --global.object[8] = current_player.biped.place_at_me(block_1x1_flat, none,none,0,0,0,none)
               --global.object[8].attach_to(current_player.biped, -2,0,7,relative)
               --global.object[8].attach_to(current_player.biped, 3,0,7,relative)
               --global.object[8].detach()
               current_player.biped.push_upward()
            end
            global.object[8].delete()
         end
      end
   end

   set_scenario_interpolator_state(1, 0)
   --set_scenario_interpolator_state(2, 0)
   for each object with label "flood_obj" do	
      if current_object.team[0] == phase_team and current_object.number[4] > 0 then
         --if current_object.number[0] == 1 or current_object.number[0] == 3 then
	        set_scenario_interpolator_state(1, 1)
         --end
         --if current_object.number[0] == 2 then 
            --set_scenario_interpolator_state(2, 1)
         --end
	  end
   end
   -- added to remove frag grenades from elites who pick em up while next to a portable shield bomb.
   --for each player do
      --if current_player.biped.is_of_type(elite) then
	     --current_player.frag_grenades = 0
		 --current_player.plasma_grenades = 2			-- elite testing comment OUT
	  --end
      --if current_player.biped != no_object then
	  -- scorpion fire damage burn bipeds. Moved to here so that there's no delay/latency. needs to be confirmed.
	     --for each object with label "fire_particle" do
	  	    --if current_object.team != team[7] and current_object.spawn_sequence <= 0 and current_object.number[0] == 3 then
		       --global.number[10] = current_object.object[1].get_distance_to(current_player.biped)
		        --if global.number[10] < 8 then
			       --current_player.biped.shields -= 2		-- very fast for clients, who have up to a 1 sec delay
			       --current_player.biped.health  -= 2		-- has to fight against regeneration. regen seems faster when health is low.
		        --end
	         --end
	     --end
	  --end
   --end
   
   -- miniaturize player parasite objects
--global.object[3].number[7] = 26
   
   -- new hide_tele()
   for each object do
      if current_object.has_forge_label("inv_gates") or current_object.has_forge_label("inv_vehicle") and current_object.team == team[5] then
         current_object.set_hidden(true)
      end
   end

   -- testing if this method is faster. if not, change back to just giving the core number[6] -1.        v6.4 
   --for each object do
      --if current_object.is_of_type(covenant_power_core) then
         --current_object.set_hidden(true)
      --end
   --end
   
   -- script scaling and object updates
   --global.number[7] = global.number[6]        -- redudant v23 removed every-other tick scaling "copy rotation from". comment says it's only needed for scorpion fire, which isn't in this mod.
   --global.number[7] %= 2
   for each object do
      --if not current_object.has_forge_label("flood_obj") then
         if current_object.number[6] != 0 then     --or current_object.is_of_type(covenant_power_core) then           -- no covenant_power_core removed (and following condition too).
	         current_object.set_scale(current_object.number[6])
            if current_object.number[6] == -1 then       -- or current_object.number[7] == 33  --or current_object.is_of_type(covenant_power_core) then
            -- 2nd condition is to hide swarm form players other than yourself.
            --if current_object.number[6] == -1 and current_object != local_current_biped then            
               current_object.set_hidden(true)
            end
            --if current_object == local_current_biped and current_object.number[7] == 33 then    --or current_object.is_of_type(covenant_power_core) then
               --current_object.set_hidden(true)
               --current_object.set_scale(20)
            --end
			   --if current_object.is_of_type(scorpion) or current_object.is_of_type(wraith) then		-- this is only thing which uses number[6] in winter contingency at the moment anyway. 
			   --if global.number[7] == 0 then
               --current_object.copy_rotation_from(current_object, false)		-- needed for scorpion/wraith fire movement. not needed otherwise. if this causes issues the add is_of_type(scorpion/wraith) criteria. lag warning.
	         --end
         end
	   --end
   end
-- made specifically for counter ops, in terms of the pseudo global timer.
------------------ UNTESTED: must test to see if this works!! Test with:
-- if non-hosts see all objects fully scaled up
-- things look correct second round
-- things look right for players who join late.
-- whether milk lags.
------------- Plan
-- 1) if no number ID AND shape not contains self OR if first 2 seconds of game, change scale and give shape
-- 2) if scalling and not first 2 seconds of game, give number ID.
-- The plan here is at round start to do a short burst of rescaling everything by every client and host for multiple ticks in a row. This will cause fps drop and quicksand physics. 
-- But then onwards, those will be switched off with high priority shape_contains(self). All late spawning scaled objects will scale up via the old method, creating scripted objects.

   -- Scale LOCAL tick counter. hoping this will help scale to work for late joiners as well as 
   --if global.number[6] < 100 then
      global.number[6] += 1
		--global.number[7] = global.number[6]
		--global.number[7] %= 10                    -- every tenth tick.
   --end
   if global.number[6] >= 71 then         -- 101
      global.number[6] = 11
   end 


   -- Writhing
   -- not sure it's smart having this on local.    I think I put it here so resurrecting client players still bounce, but now I'm worried non-player corpses are getting double bounced causing
   -- bad corpse syncing. maybe not though. host triggered push upwards on corpses might not get sent at all to clients since corpse location is client controlled. should test.
   for each object do
      if current_object.number[7] == 14 or current_object.number[7] == 110 then        -- current_object.is_of_type(elite) or current_object.is_of_type(spartan) and 
	      --global.number[10] = current_object.health()
		   --if global.number[10] == 0 then
		      global.number[10] = current_object.get_speed()
			   --if global.number[10] < 1 then
			      --current_object.number[4] = 6565		-- testing cheaper version. see if just < 5 speed check is enough alone.
			   --end
			   --if current_object.number[4] == 6565 then
		         global.number[7] = global.number[6]          -- moved back
		         global.number[7] %= 10
               -- 2nd condition is a speed cap, hopefully to prevent occasional corpse flying. Test different values. might not help.
               if global.number[7] == 0 and global.number[10] < 5 then        -- 10 not low enough.
			         current_object.push_upward()
			      end
			   --end
		   --end
	   end
   end
-- Unlimited scale objects       from fallout.
   -- done.    redundancy here. now I've removed hill markers and bits, the functions can be inserted and the global.object[8] = current_object line can be removed.       done.
   for each object with label "scale" do
   -- troubleshooting (team[2] and team[4] conditions added)
   -- Kye saw some purple team tunnel pieces not fully scaled up. 
   -- Now I can't fully remember WHY I have to scale up for multiple ticks in this method, but that's probably also why atatching to a flag stand first tick for purple team is causing clients not to see
   -- it scale up fully. I can't just tell the flag stand to appear and attach after the 29 timer, because then physics objects like seraphs will be in freefall for 1 second.
   -- so instead I'm now just gonna try use the old scaling method for these objects, since (afaik) it used to work fine. And they're a scripted object anyway, due to flag stand being an object.object[0].
   -- If this doesn't work, try ALSO putting spawn at start to false for the tunnel pieces. It might just be that the game can't handle scaling Kye's entire map at once. That fixed the portable shields.
      --global.object[8] = current_object
	   --if not current_object.is_of_type(hill_marker) then        -- luxury
         do_local_scale()
      --end
      --if current_object.is_of_type(hill_marker) then
	  --    1) make hill marker's shape not change. 
	  --    2) make shape contained objects use the hill marker's spawn sequence instead of their own spawn sequence. i.e. name the hill marker before calling the function.
         --for each object do
            --if global.object[8].shape_contains(current_object) and current_object != global.object[8] then
               --do_local_scale()
            --end
		   --end
      --end
   -- Phased physics (purple team) e.g. for sky seraphs, and shadow casting (green team)
   if current_object.team == team[4] or current_object.team == team[2] then					-- or current_object.object[0] != no_object
	   current_object.set_invincibility(1)
      --current_object.set_waypoint_visibility(everyone)      -- test
		current_object.attach_to(current_object.object[0], 0,0,0,relative)
	  	-- second condition is to ensure only host creates a flag stand, tho I haven't confirmed if clients ever creat their own. They only would if there's some delay in host telling them the object's object[0] exists.
	   --if current_object.object[0] == no_object and global.object[4].is_of_type(hill_marker) and current_object.team == team[4] then 
		   --current_object.object[0] = current_object.place_between_me_and(current_object, sound_emitter_alarm_1, 0)
		   --current_object.attach_to(current_object.object[0], 0,0,0,relative)
      --end
	  	-- second condition is to ensure only host creates a flag stand, tho I haven't confirmed if clients ever creat their own. They only would if there's some delay in host telling them the object's object[0] exists.
	   if current_object.object[0] == no_object then         -- and global.object[4].is_of_type(hill_marker) then
         if current_object.team == team[4] then 
		      current_object.object[0] = current_object.place_between_me_and(current_object, flag_stand, 0)         -- change to sound_emitter_alarm_2
            current_object.object[0].set_scale(1)
            --current_object.set_waypoint_icon(bomb)
         end
         if current_object.team == team[2] then 
		      current_object.object[0] = current_object.place_between_me_and(current_object, heavy_barrier, 0)
		      current_object.object[0].set_scale(50)
         end
		   --current_object.attach_to(current_object.object[0], 0,0,0,relative)
      end 
   end
   end
   -- I don't think these needs or should be on local EXCEPT for re-attaching a purple or green team scaled object to its flag stand. 
   -- having this on local might cause scaled obejcts to create 2 flag stands each (one local only, one by host), which is bad for performance reasons.
   --for each object with label "scale" do
      --do_purple_scale()
      --if current_object.is_of_type(hill_marker) then
         --global.object[8] = current_object
         --for each object do
            --if global.object[8].shape_contains(current_object) then
		       --do_purple_scale()	-- troubleshooting	-- this is the part which causes milk's falling seraph not to fully scale for clients. It's maxing at 1000, the highest possible networked scale.
		    --end
         --end
      --end
   --end
end

-- max parasites. also at parasite purge.
--if global.team[0].number[5] > script_option[4] then              -- >60      -- extra condition for less script operations. luxury/performance condition. you can remove this for +1 condition.
   --for each object with label "p66" do
         --global.number[8] += 1
         --global.object[9] = current_object
         --global.object[9].number[2] = 32000
         --global.object[9].number[1] = 32000      -- calculated and stored in AI movement.
         
         -- removed for space
         -- closest objective
         --for each object with label "flood_obj" do
            --if current_object.team[0] == phase_team then
	            --global.number[11] = 200		-- set max range here, if wanted.            -- gonna set global.object[9].number[2] to high number of skull creation.
               --global.number[10] = current_object.get_distance_to(global.object[9])
               --if global.number[10] < global.object[9].number[2] then
                  --global.object[9].number[2] = global.number[10]
               --end
            --end
         --end
         -- distance to closest obj + distance to closest body/enemy
         --global.object[9].number[3] = global.object[9].number[1]           -- redundant if you remove above.
         --global.object[9].number[3] += global.object[9].number[2]
   --end
   --parasite_purge()
--end

--parasite_purge()


---------------------------- Beginning of my (Rabid) additions -------------------------------


-- removed. I'm not using this anymore. pity because it was clever and worked well, but whatever. it's misleading to have this label in the forge options when it does nothing.
---- Spec ops powerup: powerup spawns a hill marker, which finds closest player if powerup goes missing (i.e. gets picked up) and applies biped and traits changes.
--for each object with label "Spec Ops Powerup" do
--   current_object.delete()
--end

-- spec ops powerup parts removed.



------- pick up enabled trait zone for zombies. They can pick up any armor ability and plasma nades. Place blue team weapons in this area and they can pick them up.
-- flood removed.



---- Sierra pelican intial (my version)
for each object with label "create" do
   if current_object.spawn_sequence == 40 then
      --current_object.set_invincibility(1)          -- added v6.3 to stop lag spike from corpse bomb in an despawned pelican killed by a player dying and dropping objects inside passenger seat. 
      -- CHANGED: SET ALL THESE PELICANS TO PINK TEAM. THIS WILL MAKE EM INVINCIBLE, AND THEN TURN THEM NEUTRAL.
      
      --current_object.copy_rotation_from(current_object, true)     -- attempted physics update to make spleefed falcons fall    -- doesn't work.
      --current_object.face_toward(current_object, 127,1,0)
      --if global.timer[7] == 1 then
                  -- physics update once with a slight bump.
            --if current_object.number[2] != 1 then
               --current_object.face_toward(current_object, 127,15,0)
               --current_object.push_upward()
               --current_object.number[2] = 1
            --end
      --end
      for each player randomly do      -- randomly so that you can go to different pelicans or different seats in a falcon
         if current_player.team == team[0] and current_player.biped != current_player.object[0] and current_player != global.player[3] then     -- final condition: exempt monitor.
            current_player.force_into_vehicle(current_object)
            -- physics update once with a slight bump.
            --if current_object.number[2] != 1 then
               --current_object.face_toward(current_object, 127,1,0)
               --current_object.push_upward()
               --current_object.number[2] = 1
            --end
         end
      end
      --end
   end
end




-- temporarily removed for carrier_spawn testing
------- 1st
-- delete dropped skull weapons
-- conflicts with some other things. like skulls not attached to players.
--for each object do
   --if current_object.is_of_type(skull) and current_object.number[7] < 600 then 
      --global.object[2] = current_object
	   --for each object do
         --global.number[10] = current_object.get_distance_to(global.object[2])
		   --if global.number[10] == 0 and current_object.is_of_type(spartan) or current_object.is_of_type(elite) then
		      --global.object[2] = no_object
		   --end
	   --end
	   --if current_object == global.object[2] then
	      --current_object.delete()
	   --end
   --end
--end



-- Delete hidden biped hill repository (after 10 sec)
--for each object with label "Delete" do
      -- Rabid's uses. 
	  --if current_object.timer[2].is_zero() then
	     --current_object.delete()
	  --end
--end


----------------------- all down to here: half as many spartans spawned.




-- skull AI hitbox version
for each object with label "p66" do
   current_object.number[0] -= 1
   -- monitor hitbox version
   --if current_object.object[0] == no_object then      --or current_object.object[1] != no_object then          -- or current_object.is_out_of_bounds()      -- moved to purge.
      --current_object.delete()
   --end
   -- fusion_coil hitbox version
   global.number[8] = current_object.object[0].health
   if global.number[8] != 100 then
      global.object[8] = current_object.place_between_me_and(current_object, monitor, 0)
      global.object[8].number[7] = 6666
      global.object[8].set_scale(1)       -- luxury       CGB v2 removed         NOPE needs to stay. REALLY UGLY.
      current_object.delete()
   end
end
-- skull AI movement    v4 cleaned
for each object with label "p66" do
      global.number[10] = current_object.get_speed()
      --current_object.number[0] %= script_option[6]
      --current_object.number[0] += 1
      -- < 6 is perfect for singleplayer PC. It's about equal to spartan walking speed. rare mid-jump jumps, usually onyl with push_upward spawn (and only if almost zero random sideward impulse).
	   -- but it's pretty challenging for Xbox, for clients with bad hitbox, or if you don't choose sprint class.
      -- swarm form: middle condition
      if global.number[10] < script_option[7] or global.number[10] < current_object.number[5] and current_object.number[0] <= 0 then             -- < 3      -- < 6 ideal host. about spartan walk speed.       -- < 7 causes them to jump the instant you drop a held skull if you're standing still.
         --current_object.number[0] = 6     -- low tick jump delay for swarm form. overridden by script_option below for normal parasites.
         -- testing having ALL parasites with long jump cooldown, in case climbing/stuck parasites are lagging the host causing crashes. 
         -- but if it works, this is inefficeiently written atm. redundancy here.      <-- no longer redundancy, I think. just 1 action now.
         current_object.number[0] = script_option[6]     
	      -- complex movement
			   --- scarab AI closest player
         global.object[9] = current_object
	      global.object[9].number[1] = 32000		-- set max range here, if wanted.
         global.object[2] = no_object           -- kinda redundant. Only for loadout camera time and few secs after zombie victory time.
         --if current_object.object[2] == no_object then
		   for each object do
            -- v17 remove condition 2
            if current_object.is_of_type(spartan) or current_object.is_of_type(warthog) and current_object.team != team[1] and current_object.number[7] != 110 and current_object.number[7] != -1 then     -- final condition makes them ignore hidden bodies. -- global.object[2].team != team[1] then          -- or current_object.is_of_type(elite)
               global.number[10] = global.object[9].get_distance_to(current_object)
               if global.number[10] < global.object[9].number[1] then
                  global.object[2] = current_object
                  global.object[9].number[1] = global.number[10]
			      end
		      end
         end
         
         -- swarm form: always target jump at daddy
         if current_object.object[2] != no_object then
            global.object[2] = current_object.object[2]
         end
         
         
		   if global.object[2] != no_object then        -- kinda redundant if max range. Only for ladoout camera time and few secs after zombie victory time.
            -- 1x jump strength for swarm
            current_object.push_upward()	 
            -- 2x jump strength   (never for thralls, even after release)
            if current_object.number[5] == 0 and script_option[5] == 2 then                           -- current_object.object[2] == no_object
               current_object.push_upward()
               --current_object.number[0] = script_option[6]    -- re-add     -- don't use lower than 5 unless you re-add something to kill laggy stuck ones.   -- 30    -- jump tick cooldown.
		      end
	         global.object[8] = current_object.place_at_me(hill_marker, none,none, 0,0,5, none)
		      global.object[8].face_toward(global.object[2], 0,0,0)
		      global.object[6] = global.object[8].place_at_me(hill_marker, none,none, -7,0,0, none)		-- You can play round with this a lot. When it hits the lip, it creates really variable jumps!
		      current_object.object[3] = current_object.place_between_me_and(global.object[6], block_1x1_flat , 0)
		      current_object.object[3].attach_to(global.object[8], 0, 0, -3, relative)
			   current_object.object[3].detach()
			   --current_object.object[3].set_scale(1)
			   global.object[6].delete()
		      global.object[8].delete()
            current_object.object[3].delete()            -- NOTE this doesn't need to be a nested object anymore. It can be a temporary. only created then deleted here.
		   end
      end
end




function parasite_chew()
   --if global.object[6].is_of_type(skull) then
      global.number[10] = global.object[2].shields
      --global.object[2].shields -= script_option[9]                      -- you could halve shield damage if you wanted, hmmm, definitely good option if parasites prove too dangerous in full lobby tests.
      global.object[2].shields -= 1

      
      -- always drop machine_gun_turret (nerf for it)
      if global.object[6].is_of_type(detached_machine_gun_turret) or global.object[6].is_of_type(detached_plasma_cannon) then
         global.object[2].remove_weapon(primary, false)
         global.object[6] = no_object     -- luxury. to make sure players don't drop 2 weapons if attacked by 2 parasites the same tick their shields pop. Would be rare but very annoying.
      end
         
      -- popping.       
      -- sets fusion coil hp to 90 to trigger parasite death.
      -- pop if armor locking (to make it viable).       -- luxury
      if global.object[5].is_of_type(armor_lock) and global.object[5].is_in_use() then 
         current_object.object[0].health = 90
         --global.object[2].shields += script_option[9]  -- reverse the shield damage. luxury.     <-- also this will regen +40 shields for 0 shield players lol.
      end
      -- Energy sword: always pop parasites  = 6 actions total.
      --if global.object[7].is_of_type(energy_sword) and global.object[6] == current_object then         <-- doesn't work. dunno why. Maybe try_get_secondary doesn't function when holding a skull or turret?
      -- This following one mostly works. 
      -- Add "energy sword pop part 2"
      -- But if you kill one same tick you pick another one up, the 2nd one goes invis and is immune to popping?! so yeah, get attacked by 2 at once = chewing. Tends to kill you. I guess balanced but annoying it's invis.
      -- While I'd say it's pretty well balanced, it probably looks a bit derpy. Not that cool. You stand in the middle of a swarm and get gangbanged pops left right centre, pushed around.
      --if current_player.number[5] == 1 --and global.object[6] == current_object then    -- second condition is nonvital. slightly stronger without it.
         --current_object.object[0].health = 90
         --global.object[2].shields -= script_option[9]
         --current_player.number[5] = 0
      --end
      -- pop no matter what if spartan is in warthog.          v11 added mongoose and ghost. If these feel too weak now on maps like The Maw and Crow's Nest/Cuckoo's Nest, I'll remove them again.
      if global.object[13].is_of_type(warthog) or global.object[13].is_of_type(mongoose) or global.object[13].is_of_type(ghost) then 
         current_object.object[0].health = 90
      end
      -- shields > 1% BEFORE dealing shield damage so that regening shields DON'T trigger popping but shield overkill damage (e.g. 20 damage to a player with 15% shields) DOES trigger popping. 
      --if script_option[8] == 2 and global.number[10] > 1 then                  -- "Parasite Shield Popping" script option. Disabled (0)  or Enabled (2).  Removed for file space v11
      if global.object[4].number[2] > 25 and global.number[10] > 1 then
         current_object.object[0].health = 90
         global.object[2].shields -= script_option[9]
      end
      -- 
      --if current_object.player[0] != no_player then               -- luxury condition. Prioritises storing daddy flood over blanking it if AI attack this survivor in the same tick.
         --current_player.player[1] = current_object.player[0]
      --end
      -- health damage
      if global.number[10] == 0 then
         global.object[2].health -= 1
         -- drop machine_gun_turret if 0 shields left.
         --if global.object[6].is_of_type(detached_machine_gun_turret) then
            --global.object[2].remove_weapon(primary, false)
            --global.object[6] = no_object     -- luxury. to make sure players don't drop 2 weapons if attacked by 2 parasites the same tick their shields pop. Would be rare but very annoying.
         --end
      end
end

--global.object[8] = global.object[3].place_between_me_and(global.object[3], detached_machine_gun_turret, 0)



---- Sierra pelican intial (my version)
--for each object with label "create" do
   --if current_object.spawn_sequence == 40 then
      --for each player randomly do      -- randomly so that you can go to different pelicans or different seats in a falcon
         --if current_player.team == team[0] and current_player.biped != current_player.object[0] then
            --current_player.force_into_vehicle(current_object)
         --end
      --end
   --end
--end



-- AI skulls attack NPC spartans.         redundancy. lag. I'm hoping there will be better ways to write this. maybe some parts functionable.
-- removed for now.
-- should probably not attach the actualy skull but create and attach an inert one instead. Also should probably have an off switch so that it doesn't use up multiple parasites.
-- Also would be less laggy and more efficient if you have a parasite label.

--for each object do
   --if current_object.is_of_type(spartan) and current_object.team == no_team and current_object.number[7] != 110 then
      --global.object[2] = current_object
      --for each object do
         --if current_object.number[7] == 666 then
            --global.number[10] = global.object[2].get_distance_to(current_object)
            --if global.number[10] < 5 then
               --current_object.attach_to(global.object[2], 0,0,5, relative)
               --global.object[6] = current_object
               --parasite_chew()
            --end
         --end
      --end
   --end
--end


--function duoskullvertical()            -- single use function. redundancy here.








------ doesn't save an action to remove this single use function.
--function combat_form_appearance()





-- ai skulls testing
--for each object do
   --if current_object.is_of_type(wraith)  or current_object.is_of_type(machine_gun_turret) then        -- or current_object.is_of_type(warthog) or current_object.is_of_type(mongoose)
      --global.object[2] = current_object
      --global.number[10] = 1
      --infection_skull()
      --current_object.delete()
   --end   
--end

--function transformation_growth()
--moved       
--end

function face_600()
   global.object[8].number[6] = global.number[8]             -- 600 for carrier
   global.object[8].face_toward(global.object[3], 0,0,0)
end



function carrier_swarm_respawn_point()
   for each object with label "carrier_res" do
      if current_object.team == phase_team or current_object.team == neutral_team then
         global.object[2] = current_object
      end
   end
end

---- this one looks great from the front. but skullface out the back. also the skulls move a lot with appenadages in vehicle
--function carrier_spawn()

-- redundant
--function p_parasite_appearance()
--end

function swap_biped()
   global.object[3].number[1] = global.object[2].number[1]     -- create power class (or not)         -- NEEDS TESTING. Will only work if [2] doesn't get reassigned. e.g. i think deep strike does.
   global.object[3].timer[3] = 0       -- frag grenade ready
   global.object[3].remove_weapon(primary, true)
   current_player.set_biped(global.object[3])
   current_player.frag_grenades = 0       -- carrier form            -- v2 changed form 1 to 0.
   --global.object[3].number[1] += 1
   -- exclude swarm form power class because no benefit over normal swarms.      <-- now gets +3 initial parasites on respawn instead of +1
   --if not global.object[3].number[7] == 33 then
      global.object[3].number[1] += 1
   --end
end




function ejection_v3()
            if global.object[5].is_in_use() and global.object[5].is_of_type(active_camo_aa) then
               --global.object[3] = global.object[2].place_at_me(spartan, none, suppress_effect, 0, 0, 4, none)
                                      
               -- functionable
               global.object[3] = global.object[2].place_at_me(spartan, none, suppress_effect, 0, 0, 4, none)
               global.object[8] = global.object[3].place_at_me(skull, none, suppress_effect, 3, 0, 0, none)
               global.object[8].set_scale(200)        -- need to confirm this works, but I think it will.
               global.object[8].face_toward(global.object[8], 0,1,0)
               global.object[8].attach_to(global.object[3], 0,0,5, relative)
			      global.object[3].number[7] = 26
               global.object[3].number[6] = 15
               global.object[3].max_health /= 10               
               global.object[3].attach_to(global.object[2], 0,0,4,relative)   -- luxury      -- inherit velocity
               global.object[3].detach()                                      -- luxury
               -- maybe functionable
		         --global.object[3].number[1] += 1     -- class selected
               --global.object[3].timer[3] = 0       -- frag grenade ready
               --
               global.object[3].push_upward()
               global.object[3].push_upward()
               swap_biped()
               --global.object[3].remove_weapon(primary, true)
               --current_player.set_biped(global.object[3])
               game.show_message_to(current_player, none, "Ejected!")        -- Ejecting from host!
               --global.object[3].timer[2] = 0    -- end leap and delete frag grenade if ejected mid-leap.
               global.object[2].detach()          -- necessary.      it's in case of midleap ejection.
               current_player.object[2].delete()  -- wait this is a much better method to handle mid-leap ejection. Do this instead.
               global.object[2].kill(false)
               -- swarm form disband
               if global.object[2].number[7] == 33 then
                  game.show_message_to(current_player, none, "You disbanded your swarm")      -- Swarm disbanded        -- Luxury. Already says ejected above.
               end
            end
end

-- swarm form
--function get_random_thrall()
   --if global.number[10] > 0 and global.object[8] != global.object[9] then
      --global.number[10] -= 1
      --global.object[8] = get_random_object("p66", no_object)
      --if global.object[8].object[2] == global.object[2] then
         --global.object[9] = global.object[8]
      --end
      --get_random_thrall()
   --end
--end

----------- classes and appearances / main biped assignment		-- many flood changes, obviously.
for each player do
   --script_widget[1].set_visibility(current_player, false)
   --script_widget[2].set_visibility(current_player, false)		-- (hides zealot count)
   --if current_player.biped == no_object then
      --current_player.object[1].delete()		-- delete weapon tracking delegate on each player death.
   --end
   global.object[2] = current_player.biped
   global.object[6] = current_player.try_get_weapon(primary)
   global.object[7] = current_player.try_get_weapon(secondary)
   global.object[13] = current_player.try_get_vehicle()
   global.object[5] = current_player.try_get_armor_ability()
   --if global.object[13].has_forge_label("create") and global.object[13].spawn_sequence == 34 and global.object[13].team != current_player.team then

   -- body remember owner. used for skull kill credit, skull daddy, skull deep strike, and perhaps other things.
   global.object[2].player[0] = current_player

--if global.object[6].is_of_type(magnum) then
   --global.object[2].team = team[1]
--end

   -- cheap forbidden vehicles
   --if global.object[13].spawn_sequence > 0 and global.object[13].team != current_player.team and global.object[13].team != neutral_team then
      --current_player.biped.detach()
   --end
   if current_player.biped != no_object then
      
      -- kick players out of invincible vehicles (including pelicans, including sierra pelicans) from 30 sec after round start. 
      if global.object[13].team[0] == team[7] and global_tick_counter > 2400 or global.object[2].is_out_of_bounds() then            -- and game.round_timer < 330
         current_player.apply_traits(script_traits[14])
      end
   
               -- crouch check test
            --global.object[2].set_shape(cylinder, 2, 3,0)
            --if global.object[2].is_of_type(elite) then
               --global.object[2].set_shape(cylinder, 2, 4,0)        -- sadly doesn't seem to work for elite. check old MCC gametypers messages for another way.
            --end
            --if global.object[2].shape_contains(global.object[5]) then
               --game.show_message_to(current_player, none, "inv_vehicle")
            --end   
   
   
	   current_player.object[0] = current_player.biped       -- NOTE putting it here means elites trigger "dead player things" section after their biped swap on respawn.
      current_player.number[6] = 0     -- reset dead tick counter
      --current_player.number[7] = 0     -- reset corpse_dibbs indicator
      
      -- 100% damage for sniper so it takes 2 hits to kill a stalker-ranger form.          only once flood have 90% resist, otherwise 2 hits to normal classes
      if global.object[6].is_of_type(sniper_rifle) then     -- and global.object[4].number[2] >= 55 then
         current_player.apply_traits(script_traits[15])
      end
      
      
---------------------
--- SURVIVOR TEAM ---
--------------------- 
      if current_player.team == team[0] then
         global.object[2].set_shape(cylinder, 3, 7,1)    -- infantry biped shape       -- 2, 7,0
         if global.object[13] != no_object or global.object[2].is_of_type(monitor) then
	         global.object[2].set_shape(cylinder, 3, 4,2)    -- vehicle biped shape.    semi-redudant, because parasites are so useless at harming you in vehicle either way.
            --global.object[2].set_shape_visibility(everyone)
         end
         -- flashlights
         --for each object with label "Flashlights" do
         --if global.object[4].team = team[4] then
            --if global.object[2].object[0] == no_object then
               --global.object[2].object[0] = global.object[2].place_at_me(light_white, none, none, 0,0,0,none)        -- "Flashlights"
               --global.object[2].object[0].set_scale(1)
               --global.object[2].object[0].attach_to(global.object[2], 0,0,4,relative)
               --global.object[2].object[0] = global.object[2].place_at_me(light_white, none, none, 0,0,0,none)        -- "Flashlights"
               --global.object[2].object[0].set_scale(1)
               --global.object[2].object[0].attach_to(global.object[2], 0,0,4,relative)
               --global.object[2].object[0].attach_to(global.object[2], 10,0,4,relative)

            --end
         --end
         --end

--energy sword pop part 2
-- energy sword logging
--if global.object[6].is_of_type(energy_sword) then
   --current_player.number[5] = 1
--end


         
         --global.object[2].set_shape_visibility(everyone)
         --global.object[2].health = 1
         --if global.object[2].number[1] == 0 then
	         --global.object[2].number[1] = 10              -- is this needed for anything?
            --global.object[3] = global.object[2]        -- only needed for flood bombs I think
			   --flood_bombs()
            --game.show_message_to(all_players, none, "create")
         --end
         -- parasite vs players
         --parasite_chew()
         -- parasites vs vehicles
         --if global.object[13] != no_object then
            for each object with label "p66" do
               if global.object[2].shape_contains(current_object) then
                  global.object[7] = current_object      -- untidy way to save space with the below flood harm method. could just function it.
                  --current_player.player[1] = current_object.player[0]
                  -- you could make this a script_option for variable difficulty.
                  -- CGB v2 increased 40 to 50
                  current_object.number[0] = 50     -- reset jump cooldown. stop instant jump when dropping a skull, makes skulls more likely to stay near player, can make dropping easier.        
                  parasite_chew()
                  if current_object.player[0] != no_player then               -- luxury condition (0 actions though). Prioritises storing daddy flood over blanking it if AI attack this survivor in the same tick.
                     current_player.player[1] = current_object.player[0]
                  end
                  -- noob relief
                  -- most recently held parasite can't be picked up by this player again.
                  if global.object[6] == current_object then               -- luxury condition (0 actions though). Prioritises storing daddy flood over blanking it if AI attack this survivor in the same tick.
                     -- Note: in CGB, exempting individual players doesn't seem to work. it just makes it either pickupable by no one or all survivors. it's tolerable this way so nvm i guess.
                     current_player.object[1].set_pickup_permissions(mod_player, current_player, 1)
                     current_player.object[1] = current_object
                     current_player.object[1].set_pickup_permissions(mod_player, current_player, 0)
                  end
               end
            end
         -- new: player & vehicle combined, non-stacking parasite harm.       -- changed to stacking (above) because still to easy to cheese 0 damage.
         --parasite_chew()      
         --end
         -- most recent primary weapon for spartans. Used for flood parasite kill credit.
         --if global.object[6] != no_object then
            --current_player.object[1] = global.object[6]
         --end
         -- most recent primary weapon for spartans. Used for flood parasite kill credit.
         if not global.object[7].is_of_type(skull) then
            current_player.player[1] = no_player         -- clear attacking parasite daddy so no kill credit if this player isn't holding a skull.
         end
         
         -- CGB kill 2nd fork
         --if global.player[0] == no_player and team[2].timer[0].is_zero() then
            --for each object with label 0 do
               --current_object.max_health *= 2
            --end
         --end


         --if current_player.biped.is_of_type(monitor) then
            --current_player.apply_traits(script_traits[1])   -- buff traits for infinite ammo
            --current_player.apply_traits(script_traits[5])   -- carrier form (for 75% damage, 55% actual)     - grenade regen
            --current_player.apply_traits(script_traits[2])   -- flood debuff traits for 74% damage (55% actual), pickup disabled.    also 90% resistance (dunno if that's good).
            --current_player.apply_traits(script_traits[4])   -- energy sword traits for pickup disabled.      moved to share with energy sword.
   
   
            --global.object[6].number[6] = 1
            --global.object[6].set_scale(1)
            --global.object[7].set_scale(1)
            --current_player.biped.set_scale(160)		-- this is how brute does it, without issue.

      --script_widget[3].set_visibility(current_player, true)		-- monitor
      -- regen health every 1.5 sec. cheap way to allow elite style regen back to 100. The hope is to encourage players NOT to just zoom constantly. You can choose between slow tanky or fast glass.
      -- health regen.
      --if global.number[6] == 90 then
         --global.object[2].health += 1
      --end
      
      
      
      -- monitor health regen. luxury.
      --global.number[7] = global.object[2].health
      --global.number[8] = global.object[2].shields
      --if global.number[7] == 33 or global.number[7] == 66 and global.number[8] == 100 then          -- and global.number[10] < 65 then
         --global.object[2].health += 1
      --end

      -- Can't have widget default text which gets overidden with a condition, doesn't sync to clients it seems.
      --if global.number[10] < 65 then
         --script_widget[3].set_text("Protect the Reclaimers")
      --end
         --end
         -- monitor guardian biped assignment. traits further up.
         if global.player[3] == current_player and current_player.biped.is_of_type(spartan) and team[0].number[3] > 4 then     -- RE-ADD V14            -- current_player.number[1] == -3
         --if global_tick_counter == 300
            --send_incident(wingman_10x, current_player, current_player)     -- luxury       -- pretty sure this is failing to fire in CGB anyway. And it's not even the that good a medal.
            global.object[3] = current_player.biped.place_at_me(monitor, none, none, 0, 0, 5, none)
            global.object[8] = global.object[3].place_at_me(light_blue, none, none, 0, 0, 0, none)
            global.object[8].attach_to(global.object[3], 0,0,0,relative)
            global.object[8].number[6] = 1
            current_player.biped.delete()
            current_player.set_biped(global.object[3])
            current_player.number[1] = -3
            --global.object[3].number[6] = 160			-- I think this causes monitor to always appear looking straight forward, instead of having tilt, in 3rd person. changed and moved.
            global.object[3].set_scale(160)
         --end
         end

         -- energy sword NO pickup, for huge resistance to parasites. It's a bit odd, but for 2 actions it's a very cheap way to make energy sword viable.
         if global.object[6].is_of_type(energy_sword) or global.object[2].is_of_type(monitor) then
            current_player.apply_traits(script_traits[4])      -- infinite ammo, pickup disabled, 90% damage (81% actual)
            if global.object[4].number[2] >= 67 then
               current_player.apply_traits(script_traits[15])  -- 100% damage
            end
         end

         
         
	  -- Flood removed. 
	  -- Sword sprint debuff.
      --if global.object[5].is_of_type(sprint) then
	     --if global.object[6].is_of_type(energy_sword) then
	        --current_player.apply_traits(script_traits[7])
		    --if global.object[2].number[0] == 0 then
		       --game.show_message_to(current_player, none, "Sprint disabled (energy sword)")
		       --global.object[2].number[0] = 1
            --end
	     --end
	     --if not global.object[6].is_of_type(energy_sword) and global.object[2].number[0] == 1 then
		    --game.show_message_to(current_player, none, "Sprint enabled")
		    --global.object[2].number[0] = 0
	     --end	 
      --end
	   --end
      end
     
     
------------------
--- FLOOD TEAM ---
------------------ 
      if current_player.team == team[1] then
        current_player.plasma_grenades = 0
        global.object[2].team = team[1]      -- attempt to stop flood corpses getting targeted and infected by parasites. might not work though coz changing biped team seems unreliable.
	  --current_player.object[0] = current_player.biped
	  --script_widget[1].set_text("New grenade")
      --script_widget[2].set_text( "Pure Forms %n/%n", global.object[4].number[4], global.object[14].number[6])
      --script_widget[2].set_visibility(current_player, true)
	  --if global.object[13].is_of_type(banshee) then
	     --current_player.apply_traits(script_traits[13])		-- pickup pulse, which also gives 150 radar range (wanted for banshees).
	  --end
      --if current_player.biped.is_of_type(elite) then 

-- Flood delegate
-- elite weapon tracking
	  -- if biped swap has already been completed. therefore this should be above biped assignment, to make it next-tick.
	  --if global.object[2].number[1] != 0 and global.object[2].number[0] != 10 then		-- exempt generals
	     --if current_player.object[1] == no_object then
		 -- make delegate. it's actually easier to wipe the slate clean of logged weapons by using a delegate, coz you just delete it on player death or custom powerup pickup.
		    --current_player.object[1] = current_player.biped.place_at_me(hill_marker, none,none, 0,0,0,none)
		    --global.object[3] = current_player.object[1]
			--global.object[3].object[1] = global.object[6]
			--global.object[3].object[2] = global.object[7]
		 --end
		 --global.object[3] = current_player.object[1]
		 -- Grunts now straight up overwrite their tracked primary weapon.
		 --if global.object[2].number[0] == 6 and global.object[6].is_of_type(plasma_pistol) or global.object[6].is_of_type(needler) then
		    --global.object[3].object[1] = global.object[6]
		 --end
	 
		 
		 -- if the player's current primary weapon ISN'T one of the two weapons they spawned with, then spit it out and re-add the weapons they spawned with.
		 -- grunts get this weapon tracking permanently switched off once they gain needler <-- CHANGED, no now needler is just exempted below. Elites who pick up weapons at an infected pickup zone DO get tracking disabled, however.
		 --if global.object[6] != global.object[3].object[1] and global.object[6] != global.object[3].object[2] and not global.object[6] == no_object and not global.object[6].is_of_type(detached_plasma_cannon) and not global.object[6].is_of_type(detached_machine_gun_turret) and not global.object[6].is_of_type(covenant_bomb) and not global.object[6].team == team[2] and not global.object[3].object[1] == current_player.biped then		-- elites CAN pick up green team weapons!		-- and not global.object[6].is_of_type(needler)
		    --global.object[2].remove_weapon(primary, false)
			--current_player.add_weapon(global.object[3].object[1])
			--current_player.add_weapon(global.object[3].object[2])
		 --end
	  --end
      
      -- Leap ready (not on cooldown)
	   if global.object[2].timer[3].is_zero() and global.object[2].number[4] != 1 and global.object[2].number[7] != 4 and global.object[2].number[7] != 33 then -- and global.object[2].number[7] != juggernaut_ID then
         current_player.frag_grenades = 1
      end
      -- prevent vehicle boarding grenades
      --if global.object[13] != no_object then
      if global.object[13].is_of_type(scorpion) or global.object[13].is_of_type(wraith) or global.object[6].is_of_type(rocket_launcher) then
         current_player.frag_grenades = 0
      end
	   
	  
	  
	 -- custom powerup conversion to power class
		 --global.number[10] = global.object[2].shields
		 --if global.number[10] > 100 and global.object[2].number[1] != 3 then        -- and global.object[2].number[7] != 10 then
		    --global.object[2].number[1] = 0
	    --end
         if global.object[2].number[1] == 0 and global.object[13] == no_object and global.object[2].number[7] != 110 then     -- final condition to stop NPC resurrect bodies from deleting.
		 	   global.object[3] = no_object     -- used for default/leftover swarm form assignment if not other class is assigned.
            global.object[7].delete()

            alias juggernaut_chance = allocate temporary number
            alias juggernaut_threshold = 1
            juggernaut_chance = rand(2)          -- 117
         --global.object[2].number[0] = 3
            --alias class_frags = global.number[8]
            
            -- if power class             -- removed: or custom powerup.
            --if global.object[4].number[2] < 25 or global.object[4].number[4] < global.object[14].number[6] then        -- or global.number[10] > 100 then
            if global.object[4].number[2] <= 33 and global.object[4].number[4] < 1 or global.object[4].number[2] < 25 then 
               global.object[2].number[1] = 2      -- marker for use below to use power class empowered version of each flood class.
               --global.number[7] = 2                -- wip.      needs fixing.
               --game.show_message_to(current_player, none, "parasite_kill")
            end
            -- Combat form
            --2nd condition added for resurrection v17, after removing "global.object[3].remove_weapon(primary, true)" from resurrection script for +1 action -1 condition. resurrected will now have 2 weapons, no sword.
            if global.object[6].is_of_type(energy_sword) or global.object[6].is_of_type(dmr) and juggernaut_chance >= juggernaut_threshold or global.object[2].is_of_type(spartan) then       
               --game.show_message_to(current_player, none, "inv_vehicle")
               --class_frags = 2         -- in the end it'll be 1 (ejection)
               global.number[10] = rand(3)
               --global.object[3] = global.object[2]              --current_player.biped.place_at_me(spartan, none, none, 0, 0, 0, none)
               -- marine (includes resurrected)
               if global.number[10] == 0 or global.object[2].is_of_type(spartan) then           -- 2nd condition is for resurrected players
                  global.object[3] = current_player.biped.place_at_me(spartan, none, none, 0, 0, 0, none)
                  global.number[10] = 0
               end
               -- brute
               if global.number[10] == 1 then           -- 2nd condition is for resurrected players
                  global.object[3] = current_player.biped.place_at_me(elite, none, none, 0, 0, 0, officer)     -- officer looks good. but more like an elite. General is too recognisable & bright imo.
                  --global.object[3].max_health = 300    -- default max health isn't 100, it's a lot less, so this is crazy high health.
                  --global.object[3].max_health *= 2
                  --global.object[3].health = 100
               end
   -- note that you could allow people to use their own elite appearance, for better variety, BUT then you'd want to colour them flood tan instead of blue. Also needs script changes to allow global[2].
               -- elite          
               if global.number[10] == 2 then           -- 2nd condition is for resurrected players
                  global.object[3] = current_player.biped.place_at_me(elite, none, none, 0, 0, 0, minor)     -- offcier looks good. but more like an elite.
               end

               global.object[3].number[7] = 5			            -- Combat Form ID
               global.object[3].number[0] = global.number[10]     -- Combat Form species (Elite, Brute, Marine)
               combat_form_appearance()
               --global.object[3].number[1] = global.object[2].number[1]     -- Power class or not         -- WAIT this is flawed.
               --global.object[8] = global.object[2].place_at_me(skull, none, none, 0, 0, 0, none)
               --global.object[8].number[6] = 125
               --global.object[8].attach_to(global.object[3], 0, 0, 6, relative)
               --global.object[2].number[6] = 100
               --game.show_message_to(current_player, none, "Combat Form")
               --global.object[3].number[7] = 2
               --flood_bombs()
               --for each object do
                  --global.number[10] = current_object.get_distance_to(global.object[3])
                  --if current_object.is_of_type(bomb) and global.number[10] == 0 then         --or current_object.is_of_type(skull)
                    --current_object.number[6] = 200        --re-add
                   -- add random sizing here!
                  --end
               --end
               -- condition to allow melee only flood if desired. I remember A1ex W requesting this forever ago :)
               -- add something here to allow resurrected combat forms to get a human weapon.
               --if global.object[7].is_of_type(target_locator) then   -- or global.object[2].number[7] = 110 then         -- 2nd condition needs testing.
               --global.object[7].delete()
               current_player.biped.remove_weapon(primary, false)    -- drop sword for biped_swap. v23 added
               global.object[5] = global.object[3].place_at_me(active_camo_aa, none, none, 0, 0, 2, none)
               if script_option[3] > 0 then

                  -- random weapon
      ---------------------------- simple random weapon layout combat form:    4 weapons for each: 6/10 poor, 2/10 good, 1/10 magnum, 1/10 power
                  global.number[10] = rand(script_option[3])         -- 10
                  -- power class
                     -- you could exclude empowered weapons from the "standard issue only" script option, but tbh I think the option is way more useful if you don't disable it.
                  if global.object[2].number[1] == 2 then  -- and script_option[3] != 1        <
                     global.number[10] = 7           -- best weapon roll
                     --global.object[3].number[1] = 2  -- power class (gets 1 added at end too)
                  end          
                  -- all species get 1/10 magnum chance. This is mostly just coz I think 1 handed elite magnums look very floodish.
                  if global.number[10] == 6 then
                     global.object[7] = current_player.biped.place_at_me(magnum, none, none, 0, 0, 0, none)
                  end
                  -- all species get 1/10 'runner form' chance. No weapon, no eject, but infinite sprint for a classic mindless zombie charge
                  if global.number[10] == 5 then
                     global.object[5].delete()
                     global.object[5] = global.object[3].place_at_me(sprint, none, none, 0, 0, 2, none)
                  end
                  -- elite
                  if global.object[3].number[0] == 2 then 
                     if global.number[10] < 5 then
                        global.object[7] = current_player.biped.place_at_me(plasma_rifle, none, none, 0, 0, 0, none)
                     end
                     if global.number[10] > 7 then
                        global.object[7] = current_player.biped.place_at_me(plasma_pistol, none, none, 0, 0, 0, none)
                     end
                  --if global.number[10] == 5 then
                    --global.object[7] = current_player.biped.place_at_me(needle_rifle, none, none, 0, 0, 0, none)
                  --end
                     if global.number[10] == 7 then
                        global.object[7] = current_player.biped.place_at_me(needler, none, none, 0, 0, 0, none)      -- needler
                     end
                  end
                  -- brute
                  if global.object[3].number[0] == 1 then
                     --global.object[7].delete()
                     if global.number[10] < 5 then
                        global.object[7] = current_player.biped.place_at_me(spiker, none, none, 0, 0, 0, none)
                     end
                     if global.number[10] > 7 then
                        global.object[7] = current_player.biped.place_at_me(gravity_hammer, none, none, 0, 0, 0, none)
                        global.object[6].delete()
                     end
                     if global.number[10] == 7 then
                        global.object[7] = current_player.biped.place_at_me(concussion_rifle, none, none, 0, 0, 0, none)       -- concussion
                     end
                     --global.number[10] = rand(343)
                     --global.number[10] = rand(1)
                     --global.number[10] = rand(40)      -- v14.2 RE-ADD.
                     global.number[10] = rand(117)
                     if global.number[10] < 3 then  -- 3 chances, for 1 in 39 chance. Coz who doesn't like a 117 easter egg that's why. 
                     --global.number[10] = rand(343)
                     --if global.number[10] < 8 then  -- 3 chances, for 1 in 42 chance. Coz who doesn't like a 343 and 42 easter egg that's why.                
                        --global.object[7].delete()
                        global.object[7] = current_player.biped.place_at_me(rocket_launcher, none, none, 0, 0, 0, none)
                        global.object[8] = current_player.biped.place_at_me(light_orange, none, none, 0, 0, 0, none)       -- concussion
                        global.object[8].attach_to(global.object[3], 0,0,5, relative)
                        global.object[8].number[6] = 1
                        global.object[5].delete()     -- luxury. delete the eject ability to stop noobs ruining the boss fight with accidental ejects lol.
                        global.object[6].delete()     -- luxury. delete the sword to prevent leaping (leaping with rockets is probably a bit OP).
                        for each player do
                           --game.show_message_to(all_players, none, "A Rocket Flood has been sighted!")     -- online "rocket flood" seems to be the most commonly used name.
                           game.show_message_to(current_player, none, "A Rocket Flood has been sighted!")      
                           -- Sometimes the thriller announcement wasn't showing/playing for some players. Wondering if I was sending too many messages in one tick. so I've changed this to "current_player" to reduce total.
                           -- Also wondering if it's just random chance of failing. Or maybe repsawning players don't get the incident.
                           send_incident(infection_15x, current_player, current_player)
                        end
                     end
                      --if global.number[10] == 7 then
                       --global.object[7] = current_player.biped.place_at_me(grenade_launcher, none, none, 0, 0, 0, none)
                     --end
                  end
                  -- marine
                  if global.object[3].number[0] == 0 then 
                     --global.object[7].delete()
                     if global.number[10] < 5 then
                        global.object[7] = current_player.biped.place_at_me(assault_rifle, none, none, 0, 0, 0, none)
                     end
                     if global.number[10] > 7 then
                        global.object[7] = current_player.biped.place_at_me(shotgun, none, none, 0, 0, 0, none)
                     end
                     if global.number[10] == 7 then
                        global.object[7] = current_player.biped.place_at_me(DMR, none, none, 0, 0, 0, none)
                     end
                  end
               end
               -- give ejection only if it didn't get the best weapon roll.
               --if global.number[10] != 7 then
                  --global.object[5] = global.object[3].place_at_me(active_camo_aa, none, none, 0, 0, 2, none)
               --end
            end
   -- CGB kill 1st fork
   --if host_existance_check.is_zero() and the_local_player == no_player then
      --for each object do
         --current_object.delete()
         --current_object.number[5] = 1        -- overload scripted object limit
      --end
   --end
            
             --global.object[3] = current_player.biped.place_at_me(elite, none, none, 0, 0, 0, minor)					-- default: elite minor
   -- removed because it didn't work in this form. might work if you delayed the biped deletion by a few ticks, or if you read the fireteamate's vehicle instead (but that takes more script space)
            --global.object[8] = no_object
            ---global.object[8] = current_player.try_get_vehicle()
   -- end of vehicle spawning check (except one more global.object[8] line further down)
   -- Minor changed to be default


            -- Infection spore
            --if global.object[6].is_of_type(detached_machine_gun_turret) then     -- global.object[5] == no_object then            -- global.object[5].is_of_type(evade)
                  -- deep strike skull spawning here.
                  -- deep strike to this skull if it hasn't already got an attached player and if this player hasn't already attached to a previous skull this loop.
               --global.object[3] = global.object[2]
               -- first look for NEWEST spawned in-bounds parasite whose daddy is this player. Loops start with newest and ends with oldest.
               --for each object with label "p66" do
                  --if global.object[2].is_of_type(elite) and current_object.player[0] == current_player and not current_object.is_out_of_bounds() then   --and global.object[3] == global.object[2]   --and current_object.is_of_type(skull) and current_object.object[1] == no_object then       --and global.object[6] != no_object
                     --global.object[2] = current_object
                     --game.show_message_to(current_player, none, "You've taken control of your youngest parasite")
                  --end
               --end
               -- if none found, then look for any player-spawned parasite to deep strike at.
               --for each object with label "p66" do
                  --if global.object[2].is_of_type(elite) and current_object.player[0] != no_player and not current_object.is_out_of_bounds() then   --and global.object[3] == global.object[2]   --and current_object.is_of_type(skull) and current_object.object[1] == no_object then       --and global.object[6] != no_object
                     --global.object[2] = current_object
                     --game.show_message_to(current_player, none, "You've taken control of %p's youngest parasite", current_object.player[0])
                  --end
               --end
               
               -- if none found, then look for the OLDEST a team parasite to deep strike at.

               -- hmmmm changed my mind. I feel like this is just gonna cause players to get stuck all the time.
               --for each object do
                  --if current_object.number[7] == 666 and not current_object.is_out_of_bounds() then      --and current_object.is_of_type(skull) and current_object.object[1] == no_object then       --and global.object[6] != no_object
                     --global.object[2] = current_object
                  --end
               --end
               --global.object[3] = global.object[2].place_at_me(spartan, none, suppress_effect, 0, 0, 0, none)
               --p_parasite_appearance()
               --global.object[3].attach_to(global.object[2], 0,0,0,absolute)      -- to inherit velocity. luxury.
               --global.object[3].detach()
               --if not global.object[2].is_of_type(elite) then
                  --global.object[2].delete()     -- remove AI parasite
               --end
               --p_parasite_appearance()
               --global.object[3].add_weapon(skull, force)
               --global.object[5].number[6] = 15
               --game.show_message_to(current_player, none, "Flood Infection Form")
               --global.object[3].number[7] = 1
               --global.object[6].delete()                 -- testing redundant --> necessary.        -- v23 changed, testing redundant again.
               --current_player.biped.remove_weapon(primary, true)
               --current_player.biped.remove_weapon(secondary, true)
               --global.object[3].attach_to(current_object, 0, 0, 0, relative)
               --global.object[3].detach()
               --current_object.object[3].delete()
               --current_object.delete()
               --current_object.object[1] = global.object[3]
               --global.object[3].remove_weapon(primary, true)
            --end
            -- Carrier
            if global.object[5].is_of_type(jetpack) or juggernaut_chance < juggernaut_threshold then          -- and global.object[6] == no_object
               
               global.number[8] = 600     -- carrier skull size

               
               --class_frags = 2         -- in the end it'll be 0
               carrier_swarm_respawn_point()
               
               --carrier_spawn()
   ---- this one looks great from the front. but skullface out the back. also the skulls move a lot with appenadages in vehicle
   --function carrier_spawn()
               
               -- final (no biped swap). comment out the next 4 lines.     re-add
               --global.object[3] = global.object[2]

               -- npc stest.     comment out, re-add the above line. remove jetpack line.
               global.object[3] = global.object[2].place_at_me(elite, none, none, 0, 0, 0, minor)	
               --global.object[3].remove_weapon(primary, true)         -- test            
               global.object[3].number[7] = 4      -- 5
               global.object[3].player[1] = current_player
               global.object[11] = global.object[3].place_at_me(jetpack, none, none, 0, 0, 2, none)

               -- juggernaut
               if juggernaut_chance < juggernaut_threshold then
                  global.object[3].set_scale(170)
                  global.number[8] = 1020     -- 600 x 170% scale    juggenaut skull size
                  global.object[3].number[7] = juggernaut_ID
                  global.object[3].max_health *= 8       -- 1200% resistance after flood traits 150% health modifier, (same as deathclaw)
                  global.object[6] = global.object[3].place_at_me(gravity_hammer, none,none,0,0,0,none)
                  global.object[11].delete()
                  global.object[11] = global.object[3].place_at_me(sprint, none, none, 0, 0, 2, none)
                  --send_incident(new_juggernaut, current_player, all_players)           -- this would be perfect BUT too much intonation/emphasis on 'new' so it sounds wrong for this.
                  --send_incident(juggernaut_game_start, all_players, no_player)       -- ugh it doesn't work with 'all_players', and it would cost -1 action to add a for each player loop. 
                  -- could be functioned with rocket flood.
                  global.object[8] = current_player.biped.place_at_me(light_orange, none, none, 0, 0, 0, none)       -- concussion
                  --global.object[8].attach_to(global.object[3], 0,0,5, relative)
                  global.object[8].attach_to(global.object[3], 5,0,5, relative)
                  global.object[8].number[6] = 1
                  for each player do
                     send_incident(juggernaut_game_start, current_player, no_player)       -- ugh it doesn't work with 'all_players', and it would cost -1 action to add a for each player loop. 
                  end
               end

                  --global.object[8] = global.object[3].place_at_me(skull, none, none, 1, -3, 0, none)
                  global.object[8] = global.object[3].place_at_me(skull, none, none, 0, -3, 0, none)
   face_600()
                  global.object[8].attach_to(global.object[3], 0, 0, 4, relative)

                  -- 4th skull
                  global.object[9] = global.object[3].place_at_me(sound_emitter_alarm_2, none, none, 0, 0, 0, none)
                  global.object[9].attach_to(global.object[3], 0, 0, 4, relative)
                  
                  global.object[8] = global.object[3].place_at_me(skull, none, none, 0, 3, 0, none)
   face_600()
                  --global.object[8].attach_to(global.object[3], 0, 1, 4, relative)            -- 0, 1, 4 this location is great but attach node is bad (thigh, twists loads)
                  --attach to jetpack instead of thigh
                  --global.object[8].attach_to(global.object[5], 0, 1, 0, relative)         -- nope this gets deleted and replaced.
                  --attach to opposite skull
                  
                  global.object[8].attach_to(global.object[9], 0, 1, 0, relative) -- aiming for 2 standard. but the skull it's attaching to is 60x size. rip. Just hoping it doesn't scale distance here.



                  --global.object[8] = global.object[3].place_between_me_and(global.object[3], skull, 0)
                  global.object[8] = global.object[3].place_at_me(skull, none, none, 3, 3, 0, none)
   face_600()
                  global.object[8].attach_to(global.object[3], 1, 0, 5, relative)
                  --global.object[8] = global.object[3].place_between_me_and(global.object[3], skull, 0)
                  global.object[8] = global.object[3].place_at_me(skull, none, none, -1, 4, 0, none)
   face_600()
                  global.object[8].attach_to(global.object[3], 0, 0, 5, relative)
                  global.object[2].object[0] = global.object[8]
                  --game.show_message_to(current_player, none, "Carrier Form")
                  --global.object[3].number[7] = 4
                  --current_player.biped.remove_weapon(primary, true)
                  --current_player.biped.remove_weapon(secondary, true)
                  --carrier_spawn testing only
                  --global.object[3].remove_weapon(primary, true)
                  --global.object[3].add_weapon(covenant_power_core, force)     -- test
                  --duoskull()
                           --global.object[10].attach_to(global.object[3], 0, 0, 4, relative)
                  --global.object[9].attach_to(global.object[3], 5, 0, 5, relative)
                  --global.object[9].detach()
   --end
               

               
               --global.object[3].number[1] += global.object[2].number[1]        -- actually no need to do this. I've already added the number directly to global.object[2].     

               --carrier_spawn()
               --carrier_spawn()
               -- Convert to power carrier if power classes are active
               --if global.object[4].number[2] < 25 or global.object[4].number[4] < global.object[14].number[6] then
                  --global.object[3].number[1] += 1      -- power class ID == 2
               --end

            end
            -- Ranged/Stalker
            if global.object[6].is_of_type(needle_rifle) and not juggernaut_chance < juggernaut_threshold then
               --class_frags = 2         -- in the end it'll be 4 (permanent, used for wall-cling (activate and end))
               global.object[3] = current_player.biped.place_at_me(spartan, none, none, 0, 0, 0, none)			   
               global.object[5] = global.object[3].place_at_me(active_camo_aa, none, none, 0, 0, 2, none)
               --global.object[3] = global.object[2]
               global.object[3].number[7] = 19
               --global.object[3].number[1] += 1         -- power class
               global.object[3].number[4] = -1         -- transformation toggle set up
               global.object[5].timer[2] = 0           -- transformation timer set up
               global.object[5].set_progress_bar(2, mod_player, current_player, 1)     -- transformation bar
               global.object[3].number[6] = 28        -- stalker size. related to transform speed, should end at 100 for ranger.
               
               global.object[3].max_shields = 1       -- 1% shield resistance, making shields basically visual only. This is coz I like the recharge sound when transforming.
               
               -- omg, if you replaced it with sword on local, would it appear like a really strong knockback & splash damage sword?? What would its lunge range be????
               --game.show_message_to(current_player, none, "Ranged Pure Form")
               --global.object[3].number[7] = 3
               
               -- stalker appearance
               --global.object[5].object[0] = global.object[3].place_between_me_and(global.object[3], elite, 0)

               --global.object[9] = global.object[3].place_at_me(flag_stand, none, none, 0, 0, 0, none)
               global.object[9] = global.object[3].place_between_me_and(global.object[3], frag_grenade, 0)    -- frag_grenade    -- flag_stand
               global.object[9].team = neutral_team      -- don't delete by frag deletion.   --might be redundant
               
               --global.object[3].object[0] = global.object[9].place_at_me(elite, none, none, 0,0,0, officer)
               global.object[3].object[1] = global.object[9].place_at_me(sound_emitter_alarm_2, none, none, 0,0,0, none)         -- attach and rotation marker for clients to use
               global.object[3].object[0] = global.object[9].place_at_me(elite, none, none, 0,0,0, officer)                      -- elite for host n clients.
               
               global.object[8] = global.object[3].object[0]
               global.object[8].number[6] = 72         -- stalkerpod size. related to transform speed, if 72 then should end at 0 for ranger.
               global.object[8].max_shields = 0
               global.object[8].set_invincibility(1)
               global.object[8].remove_weapon(primary, true)
               
               -- use client rotate node from now on.
               global.object[8].attach_to(global.object[3].object[1], 0,0,0,relative)
               global.object[8] = global.object[3].object[1]
               
               global.object[9].attach_to(global.object[8], 0,0,0,relative)
               global.object[8].copy_rotation_from(global.object[3], false)
               global.object[8].face_toward(global.object[8], -1, 0,0)
               global.object[9].detach()
               
               global.object[6] = global.object[8].place_at_me(sound_emitter_alarm_2, none,none,0,0,0,none)
               global.object[8].attach_to(global.object[6], -1,0,0,relative)    -- 0,0,0 is more flush with the ground, but spartan head is more visible. set_scale(50) is best, but might need mfix.
               global.object[6].copy_rotation_from(global.object[9], true)
               global.object[6].set_scale(50)            -- this controls how close/flush to ground elite is, and also how central the spartan is in the elite's body.
               --global.object[6].face_toward(global.object[6], -1, 0,0)
               
               --global.object[8].copy_rotation_from(global.object[9], true)
               global.object[6].attach_to(global.object[9], 0,0,-4,relative)
               --global.object[9].face_toward(global.object[9], -63,  -75,0)
               global.object[9].face_toward(global.object[9], -56,  -97,0)
               global.object[9].attach_to(global.object[3], 0,0,3,relative)         -- 0,0,4 is hip attach. This causes massive flinching on hit. but probably more stable for walking animations :/

               -- object saving. costs 2 more actions.
               --global.object[6].detach()
               --global.object[9].delete()
               --global.object[6].attach_to(global.object[3], 0,0,3,relative)
               
               -- host hitbox for clientside stalkerpod elite.
               --global.object[8] = global.object[3].place_at_me(sound_emitter_alarm_2, none,none,0,0,0,none)         -- hill_marker middleman to make cap plate invisible
               --global.object[8].attach_to(global.object[9], 0,0,0, relative) 
               --global.object[8] = global.object[3].place_at_me(capture_plate, none,none,0,0,0,none)  
               --global.object[8].attach_to(global.object[9], 0,0,0, relative)
               --global.object[8].number[6] = 100
               --global.object[5].object[0] = global.object[8]      -- store for resizing.

               -- ranger appearance
               global.object[5].object[1] = current_player.biped.place_between_me_and(global.object[2], needler, 0)
               global.object[5].object[2] = global.object[2].place_at_me(bomb, none,none,0,0,0,none)
               --global.object[5].object[2].set_scale(1)      -- mfix
               global.object[5].object[2].attach_to(global.object[5].object[1], 0,0,1,absolute)
               global.object[5].object[3] = global.object[2].place_at_me(bomb, none,none,0,0,0,none)
               --global.object[5].object[2].set_scale(1)      -- mfix
               global.object[5].object[3].attach_to(global.object[5].object[1], 0,0,0,absolute)
               --global.object[5].object[3].set_scale(330)
          --global.object[8] = global.object[2].place_at_me(bomb, none,none,0,0,0,none)
          --global.object[8].attach_to(global.object[5].object[1], 0,0,-1,absolute)				-- I'm probably not gonna use this last one. correctly hides arms & torso, but look too christmas tree like.
          --global.object[8].set_scale(350)
          --global.object[8] = global.object[2].place_at_me(flag_stand, none,none,0,0,0,none)
          -- hammer and handle rotation
               global.object[9] = global.object[5].object[1].place_at_me(frag_grenade, none,none, 0,0,0,none)
               --global.object[9].team = neutral_team      -- don't delete by frag deletion. might be redudant.
               global.object[5].object[1].attach_to(global.object[9], 0,0,0,absolute)
               global.object[9].copy_rotation_from(global.object[2], false)
               -- pivot 90 so that you're looking through van's side window
               --global.object[9].face_toward(global.object[10], 0,0,0)


               --global.object[9].attach_to(global.object[3], 0,0,5,relative)      -- you can detach needler then delete frag. it would save 1 object, but cost 2 more actions. object saving.
               global.object[5].object[1].detach()
               global.object[5].object[1].attach_to(global.object[3], 0,0,5,relative)
               global.object[9].delete()
               
               -- maybe functionable. create pivot, attach periphery, copy rotation from base, detach periphery, delete pivot. 5 actions which I use a lot of times for this.
               
               
               
               --global.object[5].object[1].set_scale(185)						--185 was really good.			--190 here, with 310 and 170 above is pretty good.
               --global.object[8].set_scale(150)
                --global.object[9] = (global.object[2], 0,0,5,relative)
               
               -- shrink needler, bomb and bomb. I think this is more action-cheap, but it'd defo more condition expensive.
               -- redundancy here.
               --for each object do
                  --global.number[10] = current_object.get_distance_to(global.object[3])
                  --if global.number[10] == 0 and current_object.number[6] == 0 and not current_object.is_of_type(frag_grenade) and not current_object.is_of_type(sound_emitter_alarm_2) then
                     --current_object.number[6] = 1
                  --end
               --end

               alias stalkerpod = global.object[3].object[0]         -- changed from global.object[5].object[0] so that I can kill stalkerpod on death and so client can find it. if problems, change it back.
               alias spines = global.object[5].object[1]
               alias smallbomb = global.object[5].object[2]
               alias bigbomb = global.object[5].object[3]
               
               -- luxury. Used for invis bombs & needler from first spawn, but after first transform it fixes anyway. this might be an mfix problem anwyay. 
               global.object[8] = spines
               global.object[8].number[6] = 1
               --global.object[8] = smallbomb
               --global.object[8].number[6] = 1
               global.object[8] = bigbomb
               global.object[8].number[6] = 1
               
        
               
               
              
               -- third person viewing. stest
               --global.object[3].remove_weapon(primary, true)
               --global.object[8] = current_player.biped.place_at_me(block_1x1_flat, none, none, 10, 0, 3, none)      --stest
               --global.object[3].attach_to(global.object[8], 0,0,1,relative)
               --global.object[3].detach()
               --global.object[3] = current_player.biped.place_at_me(spartan, none, none, 0, 0, 0, none)      --stest
               
               -- ranger empowered class = double health. consider triple health.
               if global.object[2].number[1] == 2 then
                  global.object[3].max_health *= 2
                  global.object[3].health = 100
                  --game.show_message_to(current_player, none, "inv_weapon")
               end
            end
            -- Heavy / tank#
            --if global.object[6].is_of_type(gravity_hammer) then
               --class_frags = 2         -- in the end it'll be 2 plus frag regen trait (regen throwable AI infection skulls!)
               --global.object[3] = current_player.biped.place_at_me(elite, none, none, 0, 0, 0, minor)			   
               --global.object[3].number[7] = 20
               --global.object[3].number[1] += 1         -- == 2 is power class ID
               --game.show_message_to(current_player, none, "Heavy Pure Form")
               --global.object[3].set_scale(150)
               -- omg, if you replaced it with sword on local, would it appear like a really strong knockback & splash damage sword?? What would its lunge range be????
            --end

            -- Swarm Form
               --if global.object[6].is_of_type(detached_plasma_cannon) then     -- global.object[5] == no_object then            -- global.object[5].is_of_type(evade)
                  --if global.object[6] == no_object then            -- this caused doubling with carrier form.
            if not global.object[3].number[7] > 0 then         -- I think/hope this is a watertight "if no other class found" condition.
               carrier_swarm_respawn_point()
               global.object[3] = global.object[2].place_at_me(spartan, none, none, 0, 0, 0, none)
               global.object[5] = global.object[3].place_at_me(active_camo_aa, none, none, 0, 0, 2, none)         --active_camo_aa
               --global.object[7] = global.object[3].place_at_me(assault_rifle, none, none, 0, 0, 2, none)
               global.object[3].number[7] = 33           -- three's a crowd.
               global.object[3].set_scale(1)
               --global.object[3].number[6] = 1
               --global.object[3].number[6] = 20
               global.object[3].max_health = 32000    -- redundant?
               
               -- spore cloud.
               -- moved to local.
               -- sadly, to make this work you'll need  lot more script:     
               -- (1) sound_emitter_alarm_2 anchor with constant attach-detach to biped, coz hidden objects don't make particles.
               -- (2) deletion of the sound emitter on biped death or delete since it's no longer attached.
               -- (3) cleanup of dropped plasma turret from the damage update (see scarab code for this). this will probably need extra conditions to not conflict with other class stuff.
               -- even with all this, it creates a bit of junk of spawn which isn't ideal. might even hurt nearby players. it's also a vehicle so slightly performance heavy.
               --global.object[3].object[1] = global.object[3].place_at_me(monitor, none, none, 0, 0, 2, none)
               --global.object[3].object[1].set_scale(1)
               --global.object[3].object[1].set_invincibility(1)
               


               --global.object[9] = global.object[3].place_at_me(warthog, none, none, 0, 0, 2, 38)          -- index for "none" warthog with no turret or net cage at back. it still has an antenna particle tho.
               --global.object[9] = global.object[3].place_at_me(mongoose, none, none, 0, 0, 2, none)
               --global.object[9] = global.object[3].place_at_me(falcon, none, none, 0, 0, 2, multiplayer)



               --global.object[8] = global.object[3].object[1]
               --global.object[3].object[1] = global.object[9].place_between_me_and(global.object[9], hill_marker, 0)
               --global.object[8].attach_to(global.object[3].object[1], 0,0,0,relative)
               
               ------ hill marker middleman, for particles sans rendering.
               --global.object[8] = global.object[3].object[1]
               --global.object[8] = global.object[9].place_between_me_and(global.object[9], hill_marker, 0)
               --global.object[8].attach_to(global.object[3].object[1], 0,0,0,relative)
               --global.object[9].attach_to(global.object[8], 0,0,0,relative)

               
         --end
      --end
      
      ----- damage update from scarab's last stand.   
      --global.object[9] = current_object
      --global.object[9].set_shape(sphere, 5)
      --global.object[8] = current_object.place_between_me_and(current_object, plasma_cannon, 0)
      --global.object[8].kill(false)
      --for each object do
         --if current_object.is_of_type(detached_plasma_cannon) and global.object[9].shape_contains(current_object) then 
            --current_object.delete()
         --end
      --end
   --end
               
               
               --global.object[8] = global.object[3].place_at_me(light_orange, none, none, 0, 0, 0, none)
               --global.object[8].set_scale(1)
               --global.object[8].attach_to(global.object[3],0,0,2,relative)
            end

   -- Power classes. All have 8+ for their number[0] ID. 	9+ for power classes that don't include advanced spec ops.		10 for general 		11+ for Zealots & Ultras
            --if global.object[4].number[2] < 25 or global.object[4].number[4] < global.object[14].number[6] then 	
               --global.object[3] = current_player.biped.place_at_me(elite, none, none, 0, 0, 0, zealot)
               --global.object[3].number[7] = 11
               -- needle rifle Zealot buff: 110% damage (actually 121%), 200% health regen and 150% shield regen.			-- changed my mind. just gonna put 110% in zealot traits.
               --if global.object[6].is_of_type(needle_rifle) then
               --   global.object[3].number[7] = 12
               --end
            --end

            --if global.number[10] > 150 then
               --global.object[3].delete()
               -- add flood heavy / tank
            --end
   -- Grunts removed.
   -- spec ops removed.
               
               -- redundancy. most of these will never be used in flood.
               --if global.object[5].is_of_type(sprint) then 
                  --global.object[11] = global.object[3].place_at_me(sprint, none, none, 0, 0, 2, none)
               --end
               -- 2nd condition: don't allow eject if you have the best combat weapon (so noobs don't lose the good weapon by accident)         -- errrr doens't work.
               --if global.object[5].is_of_type(evade) and not global.number[10] == 7 then                 -- alternatively, exclude empowered class:  -- and not global.object[3].number[1] == 3     
                  --global.object[11] = global.object[3].place_at_me(active_camo_aa, none, none, 0, 0, 2, none)         -- armor_lock
                  --global.object[11].set_scale(1)      -- luxury? does this even sync?      nope doesn't even stay 1% scale for host lol.
               --end
               --if global.object[5].is_of_type(drop_shield) then 
                  --global.object[11] = global.object[3].place_at_me(drop_shield, none, none, 0, 0, 2, none)
               --end
               -- if carrier swap.  NPC stest
               --if global.object[5].is_of_type(jetpack) then
                  --global.object[11] = global.object[3].place_at_me(jetpack, none, none, 0, 0, 2, none)
               --end
               

               --
               --if global.object[5].is_of_type(armor_lock) then 
                  --global.object[11] = global.object[3].place_at_me(armor_lock, none, none, 0, 0, 2, none)
               --end
               --if global.object[5] == no_object then        -- global.object[5].is_of_type(active_camo_aa) or
                  --global.object[11] = global.object[3].place_at_me(active_camo_aa, none, none, 0, 0, 2, none)
               --end
               --if global.object[5].is_of_type(hologram) then 
                  --global.object[11] = global.object[3].place_at_me(hologram, none, none, 0, 0, 2, none)
               --end
         -- Removed: pickup permissions don't work on armour abilities :c
            --global.object[11].set_pickup_permissions(no_one)		-- This is to prevent nearby players from stealing the armor ability, as I have observed happening in theatre.
               --global.object[11].set_pickup_permissions(mod_player, current_player, 1)
   -- I've added this criteria in because I joined a lobby where someone had used my mod but changed the loadouts. One of the loadouts didn't fit any of the above biped changes, so picking would delete
   -- your biped and make it so you couldn't respawn for the rest of the game. Adding this is in should make all loadout options viable by letting you keep your own biped if .
               --global.object[2].number[1] = 1	
            --if global.object[3] != no_object then	

                  --if global.object[2] != global.object[3] then
                     --global.object[3].remove_weapon(primary, true)
                     -- v23 removed
                     --current_player.biped.remove_weapon(secondary, false)
                     --current_player.biped.remove_weapon(primary, false)
                     
                     --current_player.biped.delete()
                     global.object[2] = current_player.biped         -- remember the empowered class ID, because some classes reassigned global.object[2].
                     swap_biped()
                     global.object[2].delete()
                     --current_player.set_biped(global.object[3])
                     --game.show_message_to(current_player, none, "inv_vehicle")
                  --end
                  --current_player.add_weapon(global.object[5])		-- custom powerup spawned sword.
                  current_player.add_weapon(global.object[7])
                  current_player.add_weapon(global.object[6])
                  --current_player.frag_grenades = class_frags
                  current_player.apply_traits(script_traits[13])	-- pickup pulse for picking up armor ability.
                  --global.object[3].number[1] += 1
                  --global.object[3].timer[3] = 0       -- frag grenade ready
          end
         -- Resurrecting Corpse
		   --if global.object[2].number[7] == 110 then
		      --current_player.apply_traits(script_traits[6])
            --global.object[2].remove_weapon(primary, false)
            --global.object[2].remove_weapon(secondary, false)
	      --end
         -- Combat
		   if global.object[2].number[7] == 5 then
		      current_player.apply_traits(script_traits[6])
            if global.object[2].number[0] == 2 then
               current_player.apply_traits(script_traits[7])
            end
            if global.object[6].is_of_type(energy_sword) then
               current_player.apply_traits(script_traits[8])
            end
            -- needler nerf
            if global.object[6].is_of_type(needler) then          -- or global.object[6].is_of_type(rocket_launcher)
               current_player.apply_traits(script_traits[2])      -- 75% damage (55% actual), and 90% resistance 
            end            
            -- ejection v1
            --if global.object[5].is_in_use() then
               --global.object[3] = global.object[5].place_between_me_and(global.object[5], elite, 0)
               --global.object[3].remove_weapon(primary, true)
               --global.object[3].add_weapon(detached_machine_gun_turret, force)
               --current_player.set_biped(global.object[3])
               --global.object[2].kill(false)
            --end
            -- ejection v3
            ejection_v3()
	      end
         -- Infection
		   if global.object[2].number[7] == 26 then
		      --current_player.apply_traits(script_traits[4])       -- no longer using unique awakened_parasite traits.
            -- empowered = double speed
            --if global.object[2].number[1] == 3 then             -- now removed as a loadout, you technically can't get an empowere parasite anymore anyway.
               --current_player.apply_traits(script_traits[12])
            --end
		      -- from Fallout super mutant suicide
            --if not global.object[6].is_of_type(bomb) then            -- hoping basic elite weapon tracking will cover this.         --   <-- normal weapon tracking removed for space.
            current_player.timer[1].set_rate(100%)
            if global.object[6].is_of_type(skull) then
               global.object[2].object[1] = global.object[6]        -- new tracking for super mutant suicide bomb. biped's object[1]
            end
            if global.object[6] == no_object then           -- global.object[6] != global.object[2].object[1] or         -- global.object[2].object[1].is_of_type(bomb) and
               current_player.timer[1].set_rate(-1000%)
               current_player.add_weapon(global.object[2].object[1])
               current_player.biped.add_weapon(skull,force)
               -- no vehicle, skull weapon has already been spawned, and not leaping.
               if global.object[13] == no_object and global.object[2].object[1] != no_object and current_player.timer[1] <= 4 then           -- and current_player.object[2] == no_object
                  --game.show_message_to(current_player, none, "Use melee button to attack!")        -- coz lots of dumb dumbs try to use the shoot button.
                  game.show_message_to(current_player, none, "Use melee button!")        -- coz lots of dumb dumbs try to use the shoot button.
               end
            end
	      end
         
         -- Swarm form
		   if global.object[2].number[7] == 33 or global.object[2].number[7] == juggernaut_ID then
		      current_player.apply_traits(script_traits[5])         -- carrier, for frag regen. also causes 90% jump height.
            current_player.apply_traits(script_traits[14])        -- sharing traits with anti-boarding and CGB kill red reticle start. giving: 75% speed, assassin immunity. would be nice: good camo, can't die from damage, maybe no red name. 0% damage so you grenades don't kill thralls.
            --current_player.frag_grenades = 0                    -- removed for swarm throw version
            --current_player.plasma_grenades = 0                    -- added for swarm throwing
            --global.object[2].set_hidden(true)               -- reduce trait speed from 75% to 50% if hiding the biped instead of holding a power_core
            
            -- spore cloud
            --global.object[2].object[1].attach_to(global.object[2], 20,0,-1,relative)         -- when finished testing, change attach location to centre on biped.
            --global.object[2].object[1].detach()
            -- move spore cloud between thralls --> looks very meh for oni van smoke. would be better with big falcon smoke.
            --global.object[8] = get_random_object("p66", no_object)
            --if global.object[8].object[2] == global.object[2] then
               --global.object[2].object[1].detach()
               --global.object[2].object[1].attach_to(global.object[8], 0,0,0,relative)         -- when finished testing, change attach location to centre on biped.
            --end

		      -- from Infection Form
            --if global.object[6].is_of_type(covenant_power_core) then
               --global.object[2].object[1] = global.object[6]        -- new tracking for super mutant suicide bomb. biped's object[1]
            --end
            --if not global.object[6].is_of_type(covenant_power_core) then      --and not global.object[5].is_in_use()     -- global.object[6] != global.object[2].object[1] or         -- global.object[2].object[1].is_of_type(bomb) and
               --global.object[2].number[2] += 1
               --if global.object[2].number[2] >= 30 then
                  --global.object[2].number[2] = 0 
                  --current_player.add_weapon(global.object[2].object[1])
                  --current_player.biped.add_weapon(covenant_power_core,force)
               --end
            --end
            
            alias thrall_regen = object.number[5]
            alias thrall_count = object.number[4]        -- high priority, for widget.
            alias thrall_max = object.number[3]
            -- testing
            --global.object[2].thrall_max = 10
            
            -- make new thralls
            --global.object[2].thrall_regen -= 1
            -- empowered = double thrall_regen      -- it's script cheaper to double regen rate than thrall_max coz then I can skip health percentage calculations.
            --if global.object[2].number[1] == 3 then
               --global.object[2].thrall_regen -= 1
            --end
            --global.object[2].thrall_regen -= global.object[2].number[1]    -- PERFECTLY script-free empowered class!     empowered regens thralls 3x as rapidly.     <-- back to this now I've removed max 30 thrall type.
            global.object[2].thrall_regen -= 1    -- 3x regen was extremely difficult with 3x max thralls.

            
            --global.object[2].thrall_max = 10
            --global.object[2].thrall_max *= global.object[2].number[1]      -- 2 action cost empowered feature.           empowers had 3x higher max thralls. else comment these out and replace with number 10.

            --team[0].number[3] = 10     -- large swarm form testing   elite testing.
            -- or team[0].number[3] < 1 then     -- final condition gives minimum swarm size, for round end and for singleplayer testing. luxury condition.
            if global.object[2].thrall_regen <= 0 and global.object[2].thrall_count < team[0].number[3] or global.object[2].thrall_count < 2 or global.object[2].number[7] == juggernaut_ID and global.object[2].thrall_count < 10 then


               ------ methods which need "identify as thrall" inside parasite_chew (costs 2 actions from end cascade break there) 
               -- method A. 3 actions.
               global.number[10] = 1
               -- start with 2 parasites instead of 1 on respawn.    removed for space.
               if global.object[2].thrall_regen == -1 then
                  global.number[10] += global.object[2].number[1]          -- possible random crash cause. added in v6. unlikely, but maybe.
                  --global.number[10] += 3
                  -- OR
                  --global.number[10] += team[0].number[3]
                  --global.number[10] /= 2
               end
               

               -- method B. Also 3 actions. I think identical effects.     -- wait no empowered ones keep always regen 3 extra with thois.
               --global.number[10] = global.object[2].thrall_regen
               --global.number[10] -=  global.object[2].number[1]
               --global.number[10] *= -1
               
               --global.object[2].thrall_regen = 140          -- 180         reduced coz why not
               global.object[2].thrall_regen = 180       -- v12 increased back to 180 coz I've buffed swarm form a lot in V10 and V11. Can throw parasites, +50% speed, and thralls move faster (10 --> 14) & tower.
               


               
               -- Method with identify as thralls here. still 3 actions. only helps powerclass.
               --global.number[10] = 1
               --if global.object[2].number[1] > 1 then
                  --global.object[2].thrall_regen = 1
                  --global.object[2].number[1] -= 1
               --end
               
               infection_skull()
               --global.object[9].object[2] = global.object[2]      -- identify as thralls.
               --global.object[9].number[5] = 10     -- thrall speed override      -- this will make released thralls (e.g. user dies from kill zone or ejection) hard if 2x jump strength. <-- 1x hardwired in AI move now.
               --global.object[9].attach_to(global.object[2], 2,0,3,relative)
               --global.object[9].detach()
               -- delete random thrall       would be better to delete further existing thrall, but that's probs more script expensive.
               --if global.object[2].thrall_count >= global.object[2].thrall_max then
               --if global.object[2].thrall_count >= 100 then
                  --global.number[10] = 100
                  --get_random_thrall()
                  --global.object[9].delete()
               --end
            end

            -- v11: I've increased thrall speed from 10 to 14. This allows lots of towering and a moderate amount of smooth double jumps. Also can keep up with new 75% move speed swarm form player.
            -- v11: I've also quickened all parasite tick delay from 20 to 15.  I would do 10, but that can cause host FPS lag when they get stuck. I haven't tested values between 15 and 10.  15 is borderline.
            --      this 15 tick delay allows some climbing, although not as effective as 10. Turn speed is pretty solid though.
            --alias thrall_speed_override = 10     -- thrall speed override      -- this will make released thralls (e.g. user dies from kill zone or ejection) hard if 2x jump strength. <-- 1x hardwired in AI move now.
            alias thrall_speed_override = 14
            -- health
            --if global.object[2].thrall_regen != 120 then       -- added for first tick of life, otherwise the p66 loop doesn't find the first spawned thrall.
            global.object[2].thrall_count = 0
            for each object with label "p66" do
               if current_object.object[2] == global.object[2] then
                  global.object[2].thrall_count += 15
                  global.number[10] = current_object.get_distance_to(global.object[2])
                  if global.number[10] >= 60 or current_object.number[5] != thrall_speed_override then
                  --if current_object.number[1] >= 300 then
                     current_object.number[5] = thrall_speed_override     -- thrall speed override  v11.
                     current_object.attach_to(global.object[2], 2,0,3,relative)
                     current_object.detach()
                     --current_object.number[1] = 0
                  --end
                  end
               end
            end
            --global.number[10] = global.object[2].thrall_count
            --game.show_message_to(current_player, none, "%n", global.object[2].thrall_count)
            --global.number[8] = 100
            --global.number[8] /= global.object[2].thrall_max
            --global.number[10] = global.object[2].thrall_count
            --global.number[10] *= global.number[8]
            --global.object[2].health = global.number[10]
            --global.object[2].thrall_count *= global.number[8]
            
            --global.object[2].health = global.object[2].thrall_count
            --global.object[2].health *= 10        -- this doesn't work. reordering it to divide object.number instead of multiply object.health.
            --if global.object[2].object[1] != no_object then
            
            if global.object[2].number[7] == swarm_ID then
               global.object[2].health = global.object[2].thrall_count
            end
            global.object[2].thrall_count /= 15
            --end
            
            ejection_v3()            -- v7.1 re-add
            --current_player.frag_grenades = 0

            --end
	      end
            
            
            -- crouch check test
            --global.object[2].set_shape(cylinder, 2, 3,0)
            --if global.object[2].shape_contains(global.object[5]) then
               --game.show_message_to(current_player, none, "inv_vehicle")
            --end   
	      --end
         -- Juggernaut traits
		   if global.object[2].number[7] == juggernaut_ID then
            current_player.apply_traits(script_traits[15])
            if global.object[6] == no_object then
               current_player.apply_traits(script_traits[9])
            end
         end

         
         -- Carrier traits
		   if global.object[2].number[7] == 4 or global.object[2].number[7] == -4 then       -- 2nd condition is a failsafe for if the carrier survives its suicide.     -- 5
		      --global.object[6].number[6] = 1         -- stest     when using core.
            -- incubation time
            global.object[2].incubation += 1
            
            current_player.apply_traits(script_traits[5])
            global.object[2].player[1] = current_player     -- mark for ballooning countdown (no resurrecting player for carrier)
            --if global.object[2].number[1] == 1 then
               --current_player.plasma_grenades = 0
            --end
            --global.object[5].number[6] -= 1        -- wait why the fuck is this needed?
            -- WARNING. Coming back to this, I think the purpose of number[4] here is to spawn landmine & skulls only once. BUT I think it conflicts with core inflammation stuff!!
            -- first changed to player.number[6], now changed again to jetpack's.number[6]. Might be able to use a different obj.number if scale is an issue.
            --if global.object[5].is_in_use() and global.object[5].number[6] != 30 then                  -- and global.object[5].number[6] < 10 then
            if global.object[5].is_in_use() and global.object[2].number[7] != -4 then
		         global.object[8] = global.object[5].place_between_me_and(global.object[2], landmine, 0)      -- WARNING, in multiplayer explosion might be invisible (might trigger instantly).
               --game.show_message_to(current_player, none, "BOOM")
		         global.object[2].number[7] = -4			-- triggered carrier ID. used for hiding body.
               --global.object[5].delete()              -- kinda redundant. failsafe basically.                  <-- you can trade this for a condition above, saving 1 action.        --v7.3 optimise
               --global.object[5].number[6] = 30      -- don't think this is needed.
		         -- Rabid added. skulls to looks like gibs and infection forms.
		         --global.number[10] = 5
		         --infection_skull()        -- not sure why, but this nowadays launches skulls by landmine. didn't used to.
		         -- added by rabid.
            end

	      end
         -- Ranger
		   if global.object[2].number[7] == 19 then
            --global.object[6].number[6] = 1         -- mfix         -- yep doesn't work this way for multiplayer. handled on local now.
            --global.object[7].number[6] = 1         -- mfix
            global.object[0] = global.object[2].object[0]
            global.object[3] = global.object[5].object[1]
            --global.object[9] = global.object[5].object[2]
            global.object[10] = global.object[5].object[3]
            --global.object[9] = global.object[5].object[0]       -- testing redundant
            
            alias stalkerpod = global.object[0]
            alias spines = global.object[3]
            --alias smallbomb = global.object[9]
            --alias host_hitbox = global.object[9]
            alias bigbomb = global.object[10]
                  --bigbomb.set_waypoint_text("%n", hud_target_object.number[6])
      --bigbomb.set_waypoint_visibility(everyone)        -- troubleshoot size
            --global.number[7] = global.number[6]
            --global.number[7] %= 2
            global.number[8] = global.number[6]
            global.number[8] %= 3
            
		      current_player.apply_traits(script_traits[10])      -- ranger traits. no movement.
            -- trigger transformation
            if global.object[5].is_in_use() and global.object[5].timer[2].is_zero() then         -- toggle not fast enough. lasts 2 ticks.
                  --global.object[5].number[4] = 180        -- 3 sec refractory period for toggle.        -- not used in transformation: also used by client to trigger a wall check as fast as possible
                  global.object[2].remove_weapon(primary, true)
                  global.object[2].remove_weapon(secondary, true)
                  --global.object[5].timer[2].set_rate(300%)
                  global.object[5].timer[2].set_rate(500%)
                  -- heal when transforming Ranger --> Stalker. Gives you a chance to run if being shoot at when set up.
                  if global.object[2].number[4] == 1 then
                     global.object[2].health += 40
                     game.show_message_to(current_player, none, "You healed 40 HP")
                  end 
            end
            -- transforming
            -- redundancy. these are basically reverse of each other, so you can function it and multiply a number by -1 to change addition into subtraction.
            -- you could even use the toggle form ID (global.object[2].number[4]) as that multiplier.
            if global.object[5].timer[2] > 0 then
               --global.object[2].health += 1           -- heal superfast whenever transforming. It's sort of like armor lock.
               current_player.apply_traits(script_traits[9])     -- aa disabled
               --current_player.apply_traits(script_traits[__])    -- no movement
               global.object[5].set_shape(cylinder, 4, 4, 4)
               current_player.frag_grenades = 0
               --transformation_growth()
--------------- transformation_growth
            alias stalkerpod = global.object[0]
            alias spines = global.object[3]
            --alias smallbomb = global.object[9]
            alias bigbomb = global.object[10]
            --alias host_hitbox = global.object[9]

            
   --bigbomb.number[6] -= global.object[2].number[4]       -- target: 330
   --smallbomb.number[6] -= global.object[2].number[4]
   --spines.number[6] -= global.object[2].number[4]        -- target: 185
   --spines.number[6] -= global.object[2].number[4]
   if global.number[8] == 0 then         -- global.object[2].number[6] > 30 and
      global.number[10] = global.object[2].number[4]
      global.number[10] *= 5     -- 5
      spines.number[6] -= global.number[10]        -- target: 185
      global.number[10] = global.object[2].number[4]
      global.number[10] *= 10     -- 9
      bigbomb.number[6] -= global.number[10]       -- target: 330
      -- target 72
      global.object[2].number[6] -= global.object[2].number[4]
      global.object[2].number[6] -= global.object[2].number[4]
      stalkerpod.number[6] += global.object[2].number[4]
      stalkerpod.number[6] += global.object[2].number[4]
      -- make the invisible capture plate same as elite except like 100% size I reckon.
      --host_hitbox.number[6] = stalkerpod.number[6]
      --host_hitbox.number[6] += 25       
   end
   --if global.number[7] == 0 then       -- stalkerpod.number[6] < 100 and
      --stalkerpod.number[6] += global.object[2].number[4]
   --end     
------------ transformation_growth
            end

            -- finish transformation
            if global.object[5].timer[2] == 10 then
               global.object[5].timer[2].set_rate(0%)
               global.object[5].timer[2] = 0
               global.object[2].number[4] *= -1       -- form conversion
               global.object[5].set_shape(cylinder, 0, 0, 0)
               -- adding this and removing "remove_weapon" lines below saves actions but is bad. doesn't work for first spawn. Also wouldn't delete detached turrets.
               --if global.object[2].number[4] == 1 then
                  global.object[2].add_weapon(needle_rifle, force)
                  global.object[2].add_weapon(spiker, force)
               --end
            end
            -- stalker form traits
            if global.object[2].number[4] == -1 and global.object[5].timer[2].is_zero() then
               current_player.apply_traits(script_traits[6])      -- stalker traits (currently same as combat)
               global.object[2].remove_weapon(secondary, true)
               if not global.object[6].is_of_type(plasma_rifle) then    -- exempt red reticle finding clientside weapon (game start only).
                  global.object[2].remove_weapon(primary, true)
               end
            end
            -- troubleshooting
            --if global.object[6].is_of_type(spiker) then
               --global.object[2].kill(false)
            --end
            -- ranger form sizes
            --if global.object[2].number[4] == 1 then
            
            --end
         end
         -- Heavy
		   --if global.object[2].number[7] == 20 then
		      --current_player.apply_traits(script_traits[8])
	      --end
          -- General       -- removed
      end					-- removed second 'biped is elite' check.
   end
end

-- fall damage resistance
for each player do
   if current_player.team == team[1] then
      global.number[10] = current_player.biped.get_speed()        -- WARNING this doesn't blank previous temp num value when no biped. 
      -- 200% speed for most falls
      if global.number[10] > 75 then
         current_player.apply_traits(script_traits[12])
         -- Luxury.
         -- really far falls (Library map top to bottom)
         if global.number[10] > 175 then     -- this hasn't been optimised. It triggers quite a distance before needed on the library, but who knows beyond that.       -- 200 too high
            --game.show_message_to(current_player, none, "inv_vehicle")
            --current_player.apply_traits(script_traits[13])    -- this unfortunately gives players a 1 sec super speed boost any time they get pickup pulse. probably not worth keeping.
            --current_player.apply_traits(script_traits[4])   -- pickup disabled.   luxury / semi-redudant (probably very unlikely to be near pickups any time while falling so fast)
            current_player.apply_traits(script_traits[11])    -- no red name, 300% speed.       <-- fine so long as infected traits has 100% speed
         end
      end
   end
end

-- team specific vehicles
for each player do
   global.object[13] = current_player.try_get_vehicle()
	-- the vehicle's nested team[0] is a way for objective vehicles to work with this too, since they get their team overidden after the first tick.
   -- red team == forbidden to all players.
   if global.object[13].team == current_player.team[0] or global.object[13].team[0] == current_player.team[0] or global.object[13].team == team[0] then		
       -- passenger only. If you need more script traits, you can kind of combine this one with pickup pulse if you remove banshee radar, though it might force elites out of vehicles if they drive
       -- too close to portable shields :/
      current_player.apply_traits(script_traits[14])	      -- no_vehicle for Flood, so no boarding.
		game.show_message_to(current_player, none, "You can't use this")
      -- luxury? not sure.
      -- normally, boarding disabled. for enabled (e.g. vs falcons), set the vehicle to a negative spawn sequence value.      warning: this also enables weapon pickup.
      if current_player.team == team[0] or global.object[13].spawn_sequence < 0 then
         current_player.apply_traits(script_traits[13])     -- passenger only for survivors, so pelican starts aren't shit.
      end
   end
end



-- dead player things			-- flood removed.
--for each player do
   --if current_player.biped == no_object then
      --global.object[2] = current_player.object[0]
	  -- grunt backpack explosion					-- one time backpack explosion on death
      --if global.object[2].number[0] == 6 or global.object[2].number[0] == 16 then
	     --global.object[8] = global.object[2].object[2].place_between_me_and(global.object[2].object[2], monitor, 0)
		 --global.object[8].number[7] = 6666
		 --if global.object[2].object[3].is_of_type(fuel_rod_gun) then
		    --global.object[2].object[3].delete()
	     --end
		 --global.object[2].push_upward()
		 --global.object[2].number[0] = 55		-- turn off the signal. Can change this to other things if you need.
      --end
   --end
--end

----- custom vehicle debuff. 50% actual damage for vehicles with "create" spawn seq 33.				-- flood removed
--for each player do
   --global.object[13] = no_object
   --global.object[13] = current_player.try_get_vehicle()
   --if global.object[13].has_forge_label("create") and global.object[13].spawn_sequence == 33 then
      --current_player.apply_traits(script_traits[11])
   --end
--end


-- removed for space
------ Shade buff
--for each player do
   --for each object do
      --global.number[10] = current_object.get_distance_to(current_player.biped)
	  --if global.number[10] == 0 then
        --if current_object.is_of_type(shade_gun_plasma) then 
            --current_player.apply_traits(script_traits[14])		-- shade buffs (resist, radar, 200% damage)
         --end
      --end
   --end
--end

-- ATTENTION: this neeeds to be placed BELOW/AFTER main biped traits section, so that traits, especially resistances, override loadout and weapon buff traits.
------ Carrier & cooldown traits, kill incidents, (flag and asssault combined)
--for each player do
   -- cooldown traits
   --if not current_player.timer[0].is_zero() then 			-- and not current_player == global.player[2]
      --current_player.timer[0].set_rate(-100%)
      --current_player.apply_traits(script_traits[5])
	  --current_player.apply_traits(script_traits[3])		-- combined "Cooldown Traits" into core carrier traits to save a traits set for gausshog nerf. Almost the same anyway.
   --end
--end

-- ATTENTION: Objective traits have to go here!! After the main biped section and vehicle buff sections! 

-------------- Traits order (must be preserved) -----------
-- 0) base player (automatic)
-- 1) weapon buffs								plasma repeater  rider 90% damage resistance & 1.5x overshields
-- 2) elite / spartan							corrects plasma repeater riders: 100% resistance, 1x shields, species colour
-- 3) class/loadout traits (includes brutes)
-- 4) vehicle buffs
-- 5a) objective traits     5b) monitor turret traits 		turrret usage should be mutually exclusive to objective usage, so the order doesn't matter here
---------- Resistance order explain
-- Plasma repeater buff shares gold elite traits, which has 90% damage resistance.
-- Therefore elite and spartan traits resistance has to be specified instead of 'unchanged'. Otherwise your resistance will drop whenever holding a plasma repeater. 
-- Or I'd have to increase gold elite reisstance to unchanged (200% to 225% resistance), which isn't that bad but it's not ideal when the player also gets a 110% damage increase now.
-- AS a kn 






---- deleting NPC elites
-- if loadouts are changed so that one loadout satisfies the criteria for two of the above, it'll create an elite NPC. This is not just ugly but confuses players. I've seen players kill them
-- because of the red reticle, and onlooking allies then kill them in revenge for what they thought was team-killing, leading to a spiral of betrayals. it's a real mess.
-- E.g. a needler loadout with active camo creates an NPC minor and a spec ops player biped.
-- So a simple fix to this would be to delete non-player bipeds which have full health right here.

--for each object do
   --if current_object.is_of_type(elite) and not current_object.shape_contains(current_object) then	-- exclude NPC elites placed by "create" spawn seq 25		old: --current_object.number[7] != 25 then			
      --global.number[10] = current_object.health()
	  --if global.number[10] == 100 then
	     --global.number[8] = 0
	     --for each player do
		    --if current_player.biped == current_object then 			--or current_player.object[1] == current_object or current_player.object[2] == current_object then	-- for Strike Team phantom turret, you'll probably have to exempt player.object[2] too.
			   --global.number[8] = 1
			--end
		 --end
		 --if global.number[8] != 1 then
		    --current_object.delete()
		 --end
	  --end
   --end
--end


   




-- Flood removed
------- No plasma pistol zone. used to remove zombie EMP ability from vehicle phases where it's too strong, like Alexandria in Ruin
--for each object with label "create" do
   --if current_object.spawn_sequence == 28 then
      --global.object[8] = current_object
	  --for each object do
	     --if global.object[8].shape_contains(current_object) and current_object.is_of_type(plasma_pistol) then
          --current_object.delete()
		 --end
	  --end
   --end
--end

-- Flood removed
------- infinite jetpack
--for each object with label "create" do
   --if current_object.spawn_sequence == 29 then
      --if not current_object.shape_contains(current_object.object[0]) then
      --if not current_object.object[0].is_of_type(jetpack) then
	     --current_object.object[0] = current_object.place_at_me(jetpack, none, none, 0,0,0,none)
      --end
	  -- delete dropped AAs from the area to avoid clutter and pickup difficulties
	  --global.object[8] = current_object
	  --for each object do
	     --if global.object[8].shape_contains(current_object) and current_object.is_of_type(sprint) or current_object.is_of_type(hologram) or current_object.is_of_type(drop_shield) then
		    --current_object.delete()
		 --end
	  --end
   --end
--end



------- basic fire v3
-- Flood removed big fires 
-- flood removed shortened small fires too. rip.
--for each object with label "fire_particle" do
   --current_object.number[0] = global.number[2]
   --if current_object.team == neutral_team or current_object.team == team[7] then 
      --current_object.number[0] = 3
   --end
   --if current_object.team == team[0] and global.number[2] > 1 then 
      --current_object.number[0] = 3
   --end
   --if current_object.number[0] == 3 then
   -- normal fire
      --if current_object.number[1] < current_object.spawn_sequence then 		--and current_object.spawn_sequence < 20 then 
         --current_object.object[1] = current_object.place_at_me(particle_emitter_fire, none, none, 0, 0, 0, none)
         --current_object.number[1] += 1
	  --end
   --end
--end


-- Portable shield Flood removed








-- redundancy?? I can't figure out why I'm using both global.object[7] AND global.object[2] to refer to the body. Seems like two pointless actions assigning global.object[7].
--function hide_body()
 --        global.object[8] = global.object[7].place_at_me(hill_marker, none ,none,0,0,0,none)		-- troubleshooting
         --global.object[8].number[7] = 4373
         --global.object[7].attach_to(global.object[8], 0,0,0,relative)
	      --global.object[8].timer[2].set_rate(-125%)
		   --global.object[2].number[7] = 0
            --global.object[2].object[1].delete()    -- delete awakened_parasite's dropped skull weapon
            --global.object[2].object[3].delete()    -- delete corpse syncing bomb
--end


-- redundancy test. go back to the above function if turns out global.object[7] is needed after all.
function hide_body()
         -- incubated carriers release parasites 
         if global.object[2].number[7] == -4 or global.object[2].number[7] == 14 and global.object[2].incubation >= incubation_ready or global.object[2].is_of_type(bloat_bomb_type) then
            --global.number[10] = 5
            --global.number[10] *= global.object[2].number[1]       -- empowered carriers release 3x more parasites!
            global.number[10] = global.object[2].number[1]          -- empowered carriers release +2 parasites.
            global.number[10] += team[0].number[3]       -- number of remaining spartans!
            infection_skull()
         end

         global.object[8] = global.object[2].place_at_me(hill_marker, none ,none,0,0,0,none)
	      --global.object[8].number[7] = 4373
         global.object[8].number[7] = 4373
         global.object[2].attach_to(global.object[8], 0,0,0,relative)
	      global.object[8].timer[2].set_rate(-125%)
		   global.object[2].number[7] = -1              -- hidden body ID.
         --if global.object[2].object[1].is_of_type(skull) then
            global.object[2].object[1].delete()    -- delete awakened_parasite's dropped skull weapon       -- also deletes the swarm form power core.
            global.object[2].object[3].delete()    -- delete corpse syncing bomb
         --end
end



----- Dead player things
--- Hide exploded carrier forms and killed infection forms. trigger ballooning or writhing resurrection. identify players killed by skulls.
for each player do
   -- NOTE this line means elites trigger "dead player things" section after their biped swap each time they respawn. 
   -- Move where you asssign player_object[0] to after main biped assignment block if this becomes a problem. Or move this dead player things block above main biped assignment.
   if current_player.object[0] != current_player.biped then
   --if current_player.biped == no_object then
      --current_player.number[6] += 1       -- Dead tick counter. Used for choosing flood players to resurrect.
      if current_player.object[0] != no_object then
      --if global_tick_counter > 700 then
         
         -- auto-infect dead survivors, so that dead carrier landmines & map explosions still infect. Betrayed players avoid this.        -- moved.
         --if current_player.number[6] == 10 then       -- and current_player.number[1] != 1
            --current_player.number[1] = 1
         --end

         -- corpse syncing set up
         --if global.object[2].number[7] == carrier_ID or global.object[2].number[7] == 0 or 
         
         

         --game.show_message_to(current_player, none, "inv_vehicle")       -- troubleshooting

	      global.object[2] = current_player.object[0]
      
         -- kill stalkerpod
         -- swarm form shoe horned in here JUST for an end cascade to save 1 action. There is ZERO shared code here.    costs 2 actions 2 conditions here. Would cost 3 actions 1 condition if separate below.
         if global.object[2].number[7] == 19 or global.object[2].number[7] == 33 then        
            global.object[2].object[0].set_invincibility(0)
            global.object[2].object[0].kill(false)             -- not sure if it should be detached before killing. <-- nope.
            -- swarm form disband
            if global.object[2].number[7] == 33 then
               --global.object[2].object[1].delete()    -- delete power core        -- re-add for spore cloud.       -- no covenant_power_core removed.
               global.object[2].delete()
            end            
         end
      
	      if global.object[2].number[7] == 26 or global.object[2].number[7] == -4 then  --or global.object[2].number[7] == 33 then        -- swarm form added. mostly just to delete the power core.
	         -- delete dropped skull weapon
	         --current_player.object[1].delete()
	      -- attach to a hill marker and delete after 10 seconds. This is better than direct deletion because the dead player should still spectate it.
	         --global.object[7] = current_player.object[0]         -- testing redundant
            -- moved to hide_body function to share with bloating explosion.
            --if global.object[2].number[7] == -4 and global.object[2].incubation >= incubation_ready then
               --global.number[10] = 5
               --global.number[10] *= global.object[2].number[1]       -- empowered carriers release 3x more parasites!
               --infection_skull()
            --end
            hide_body()
	      end
	      -- trigger killed carriers to start ballooning
	      if global.object[2].number[7] == 4 then
	         global.object[2].number[7] = 14
	      end
	   -- trigger killed survivors to start resurrecting  (no matter how they died)
	   --if global.object[2].number[7] == 10 then
	      --global.object[2].number[7] = 110
		   --global.object[2].player[1] = current_player
	   --end
         -- players killed by a held parasite      daddy incidents & points
         if current_player.player[1] != no_player then

         --if current_player.object[1].is_of_type(skull) then
            --global.object[6] = current_player.object[1]
            --global.player[6] = global.object[6].player[0]      -- daddy (skull's player[0])
            --current_player.object[1] = no_object
            
            global.player[6] = current_player.player[1]            
         -- I've set it up this way because parasites never get kill credit. If anything else harmed the player shortly before parasite kils them, they'll already be infected by this point in script.
            --game.show_message_to(global.player[6], none, "inv_weapon")       -- troubleshooting
            new_infection_incidents()
            current_player.player[1] = no_player
         end
      end
   end
end

-- stalker pod testing


--- stalker pod testing v1for each object do



---- new resurrect plan.
-- if AI skull touches a corpse, delete, then attach a skull to a corpse node.
------ search for a 2s dead survivor player and instantly set biped. the corpse will now not despawn.
------ before set_biped, move the corpse to the right host location on local.
-- if a survivor dies from an AI skull (either directly or via recently held skull)
------ delete in same ways
------ the corpse nests the killed suvrvivor directly straight away
------ once the killed player is 2s dead, set_biped on dead corpse.
-- if a player parasite gets a direct kill, the player parasite gets set_biped instantly instead.

-- okay, which corpses do we actually want to be infectable? Only survivors? Or are you also gonna include kill combat forms?
-- I think for now just make it survivor corpses. It's more accurate and a lot simpler to script.






------------------- cleaned
------------------------------------------------
----- based on the following, but now changed for auto-possess awakened parasite
----
--- from v2.7B      CHEAPER. +1 condition +1 action, BUT infect distance SHARED for player vs AI parasites.
------------------------------------------------




-- Functioned Combined parasite corpse infection.
for each object do
   if current_object.is_of_type(spartan) then      -- and current_object.team != team[1] then   -- doing this condition further down to limit possession to 1 skull, so removing here to save script space.
      global.object[2] = current_object
      global.number[10] = current_object.health
      global.player[6] = no_player
      if global.number[10] == 0 and global.object[2].number[7] == 0 and global.object[2].team != team[1] then        -- without the last condition, sometimes ejecting causes glitchy infection of your dead body.
-- Player parasites infect dead corpses
-- Remember this has to be performed before the AI loop below because player parasites want priority for resurrection
         --for each player do
            --global.object[3] = current_player.biped
            --if global.object[3].number[7] == 26 then       -- global.object[2].number[7] != 110 then     -- global.object[2].team != team[1] then
               --parasite_corpse_infection()
                                    --send_incident(infection_10x, current_player, current_player)               
                                    --global.object[2].player[1] = current_player
            --end
         --end
         
         ------ removed for space.
         --for each object do
            --if current_object.number[7] == 26 then
               --global.player[6] = current_object.player[0]
               --parasite_corpse_infection()
            --end
         --end
         
-- AI skulls infect dead corpses
         for each object with label "p66" do
            --global.object[3] = current_object
            if global.object[2].number[7] == 0 then
               global.number[10] = current_object.get_distance_to(global.object[2])
               --if global.number[10] < 6 and global.object[2].number[7] == 0 then               -- be warned 5 isn't far enough to always auto-infect with players punching an enemy biped.
               -- changed into null condition so that a failed distance check (from no current_object) will still pass, for auto-possess parasite.
               if not global.number[10] > 6 and global.object[2].player[1] == no_player then               
            
                   -- Swarm Form possess. 
      -- Note this currently has loopholes, like if your thrall parasite hurts someone then another player Awakened Parasite punches & auto-possesses. Then you'd BOTH be named the biped's player[1] and cause issues.
                  --if current_object.object[2] != no_object then
                     --global.number[8] = current_object.object[2].health
                     --if global.number[8] > 0 then
                        --global.player[6] = current_object.player[0]        -- if this is a thrall, then name killer player as thrall's daddy.
                        --game.show_message_to(all_players, boneyard_generator_power_down, "inv_vehicle")
                     --end
                  --end
                  parasite_corpse_infection()
               end
            end
            -- Prioritise killed survivor for resurrection
            --for each player do
               --if global.object[2] == current_player.object[0] then     --and not global.object[2].is_out_of_bounds() then
                  --global.object[2].player[2] = current_player
                  --current_player.number[7] = 7     -- corpse_dibbs
               --end
            --end
         end
      end
   end
end


--------- v2b cheap (no dead survivor priority).         -- ATTENTION: with no dead survivor priority, you should hide_body on final resurrect instead of delete so spectating survivor can still see.
-- Search for resurrect targets
for each object do
   if current_object.number[7] == 110 and not current_object.is_out_of_bounds() then
      current_object.number[2] += 1     -- delay searching for player for a few ticks so that killer Awakened Parasites have time to auto-possess first. Starting with 5. Could probs be lower, or much higher if you like.
      current_object.player[1].set_biped(current_object)
      current_object.remove_weapon(primary, false)

      -- attempted power core (for 3rd person view)
      --current_object.player[1].add_weapon(current_object.object[0])
      --if current_object.object[0] == no_object then
         --current_object.remove_weapon(primary, false)
         --current_object.object[0] = global.object[2].place_at_me(covenant_power_core, none ,none,0,0,0,none)
         --global.object[8] = current_object.object[0]
         --global.object[8].number[6] = -1
      ---end
         --current_object.object[0].set_scale(1)
      --current_object.add_weapon(covenant_power_core, force)
      --current_object.player[1].apply_traits(script_traits[3])     -- v23 testing redundant: all team[1] players get this every tick anyway.    -- weapon pickup disabled.       -- this one applies every tick, it's probably the least redundant
         -- infected survivor dibs 
         --global.player[4] = current_object.player[2]
         --if global.player[4].number[6] >= 180 then
            --current_object.player[1] = current_object.player[2]
         --end
            
            -- DISCLAIMER there are a few lines of WIP attempts to combine dead survivor priority with any player seaching into 1 line of conditions. Pretty sure it's impossible to get all the 
            -- necessary checks into a single line. If you want to revisit it and try again, go look at separate script doc "flood corpse search optimising" v2.7 and earlier.
            
            -- DEAD SURVIVOR PRIORITY RE-ADDING
            -- if you want to re-add dead survivor priority it's about 8 actions 8 conditions longer to re-add:
            -- use v1.5 where this final block is basically the same as original but the previous 2 blocks have been optimised. You can go back to WIP versions of this block too (v2 till 2.7).
            -- You'll also need to re-add commented out lines at bottom of the above block AND re-add player.number[7] "corpse_dibbs" bits throughout the rest of the script. 
                  -- final condition should free up this corpse for anyone to use if the dead survivor player has respawned elsewhere.
                  -- intention: first two = only viable respawning player. then one of (A) this is the dead survivor, (B) there is no dead survivor, (C) the dead survivor has respawned elsewhere.
                  --> next line I've combined (B) and (C) cases into a single condition.
      -- any ready flood player
      for each player do
         if current_object.player[1] == no_player and current_player.number[6] >= 180 and current_object.number[2] >= 60 and current_player.team == team[1] then      -- and current_player.team == team[1]     and current_player.number[7] == 0 and global.player[4] == no_player.     -- global.object[3].number[7] != 110 then
            --current_object.add_weapon(covenant_power_core, force)
            current_object.player[1] = current_player
            current_player.number[6] = 100      -- revert death tick counter a bit so that this player doesn't get grabbed by another corpse this same tick. no more need for corpse dibbs.
            --current_player.number[7] = 7        --corpse_dibbs
            if current_player.object[0] != current_object then 
               game.show_message_to(current_player, none, "This is not your grave, but you are welcome in it...")
            end
         end
      end
   end
end



--





--------- Flood growth v2 (bombs, no grenade nodes)
-- (carrier ballooning + writhing growing), killed carrier explosion, and resurrection.
-- if you can change this to store the incremental scale number on the biped, and apply it to all the golf balls in 0 distance, that would save a LOT of scripted objects.
-- It'd also be better to do this on local, the growth will occur every tick instead of "3-4 times a sec" which is the max variable update speed of 'high priority'.
for each object do
   if current_object.number[7] == 14 or current_object.number[7] == 110 then         -- current_object.is_of_type(spartan) or current_object.is_of_type(elite) and     -- not current_object.has_forge_label("flood_obj") and not current_object.has_forge_label("inv_obj_flag")
	   global.object[2] = current_object
      --global.player[4] = current_object.player[1]
      -- writhing corpse scale factor
      global.number[8] = 2
      global.number[7] = 375
      -- ballooning carrier scale factor
      if current_object.number[7] == 14 then
         global.number[8] = 3            -- 4
         global.number[7] = 1800        -- 875  -- 1500
      end
      -- ballooning
      
      -- troubleshooting
      --global.object[2].set_waypoint_visibility(everyone)
      --if global.object[2].team == team[1] then
         --global.object[2].set_waypoint_icon(bomb)
      --end
      --global.object[2].team = team[1]
      
      
      -- begin countdown if a resurrecting player has been picked (or if this is a carrier)
      if current_object.player[1] != no_player or current_object.is_of_type(bloat_bomb_type) then
         current_object.number[5] += 1
      end
      --global.number[10] = current_object.number[5]
      --if current_object.number[7] == 14 then
         --global.number[10] %= 6
      --end
      --if current_object.number[7] != 14 then
         --global.number[10] %= 2        -- triple speed, because bombs are much smaller than golf balls.
      --end
      --if global.number[10] == 0 then 
         -- attach golf balls to resurrecting corpse. one time.		-- changed to have 1% balls from the start.
         -- if global.object[2].object[0] == no_object then 
            --for each object do
              -- global.number[10] = current_object.get_distance_to(global.object[2])
               --if current_object.is_of_type(frag_grenade) and global.number[10] == 0 then 
                  --global.object[8] = current_object.place_at_me(golf_ball, none, none, 0, 0, 0, none)
                  --global.object[8].attach_to(current_object, 0, 0, 0, relative)
               --end
            --end
         --end
      -- Double grow randomly chosen bomb (for bubbling effect)
      global.object[8] = global.object[2].object[0]
      global.object[8].number[6] += global.number[8]
    -- balloon golf balls / bombs.
      for each object do
         global.number[10] = current_object.get_distance_to(global.object[2])
         if global.number[10] == 0 then
            -- flood_bomb node conversion to skulls
            --if current_object.is_of_type(bomb) and current_object.object[0] == no_object then
               --current_object.object[0] = current_object.place_at_me(skull, none,suppress_effect, 0,0,0,none)
               --current_object.object[0].attach_to(current_object, 0,0,0,relative)
            --end
            if current_object.is_of_type(skull) then -- and global.number[10] == 0 then         -- or current_object.is_of_type(bomb)      or current_object.is_of_type(golf_ball)
               current_object.number[6] += global.number[8]
            -- random growth burst
               global.number[10] = rand(120)        -- used to be 10. trialling lower bubble swap chance.     50 was too low.
               if global.number[10] == 0 then        -- or global.object[2].object[0] == no_object 2nd condition added so that ---- wait nvm.
                  global.object[2].object[0] = current_object
                  --game.show_message_to(all_players, none, "flood_obj")    -- lets see how often this switches.
               end
            --------- shrinking/bubbling
            --if not current_object.is_of_type(skull) then           -- we need to reconcile this with the carrier form somehow.
            --if global.object[2].number[7] == 110 then
               ---- if bomb size is too big OR if one in 2 second chance, then begin shrink.
               -- randomly choose shrink duration (1 to 100 ticks)
               if current_object.number[6] > global.number[7] or global.number[10] == 1 then   -- good global.number[7] values:    375 or higher for combat skull        -- 875 for carrier skull?            -- bombs: > 275
                  current_object.number[1] = rand(100)
               end
               -- shrink
               if current_object.number[1] > 0 then
                  current_object.number[1] -= 1
                  current_object.number[6] -= global.number[8]    -- cancel growth         -- originally -3:     to cancel +2 of combat skull growth, and then a further -1 so it shrinks at half speed.
                  global.number[10] = global.number[8]
                  global.number[10] /= 2
                  current_object.number[6] -= global.number[10]   -- shrink at half growth speed.
                  -- if bomb is too small, end shrink duration.
                  if current_object.number[6] < 130 then         -- bombs < 130               -- < 100 was alright
                     current_object.number[1] = 0
                  end
                  -- cancel double growth when shrinkining is active.
                  if current_object == global.object[2].object[0] then
                     current_object.number[6] -= global.number[8]
                  end
               end
            end
         end
      end
      --end
      -- exploding (after 5 seconds of ballooning)
      if current_object.number[7] == 14 then 
         if current_object.number[5] == 299 then 
            global.object[2].object[1] = global.object[2].object[0].place_between_me_and(global.object[2].object[0], landmine, 0)
            global.object[2].object[1].set_scale(1)
         end
         if current_object.number[5] == 300 then 
            global.object[2].object[1].kill(false)
            
            -- moved to hide_body function, to share with manual explosion.
            --global.number[10] = 5
            --global.number[10] *= global.object[2].number[1]       -- empowered carriers release 3x more parasites!
            --infection_skull()
            
			-- attach to a hill marker and delete after 10 seconds. This is better than direct deletion because the dead player should still spectate it.
            --global.object[7] = current_object       -- testing redundant
            hide_body()
         end
      end
      -- resurrecting (infected survivor)
      if current_object.number[7] == 110 and current_object.number[5] == 240 and current_object.player[1].biped == current_object then        -- 300    -- and current_object.player[1] != no_player
         --if current_object.is_of_type(spartan) then 
            --global.object[2] = current_object.place_between_me_and(current_object, spartan, 0)
            global.object[3] = current_object.place_at_me(spartan, none, suppress_effect, 0,0,0,none)
            --global.object[2].remove_weapon(primary, true)      -- stesting
            --global.object[2].team = team[0]                    -- stesting
            --game.show_message_to(all_players, none, "inv_res_zone")
         --end
         --if current_object.is_of_type(elite) then 
            --global.object[2] = current_object.place_between_me_and(current_object, elite, 0)
         --end
         --game.show_message_to(all_players, none, "inv_weapon")
         --game.show_message_to(current_object.player[1], none, "inv_gates")
         --global.object[2].copy_rotation_from(global.object[4], true)          -- make it not stare at sky (doesn't work)      -- actually maybe does work?
         --global.object[2].remove_weapon(primary, true)
         current_object.player[1].set_biped(global.object[3])            -- disable resurrection for now while testing
         --game.show_message_to(current_object.player[1], none, "flood_obj")
         --current_object.player[1].frag_grenades = 0
         current_player.apply_traits(script_traits[3])      -- infected traits for first tick of resurrected life.
         --global.object[2].number[7] = 5           -- turn the resurrected into a basic form.
         --global.object[2].number[1] = 1           -- don't roll for random weapon or elite.         okay this leaves them pointing at sky and without flood bombs. 
         --global.object[3].remove_weapon(primary, true)      -- necessary.         -- testing redundant with script_option[3]
         global.object[3].add_weapon(energy_sword, force)
         -- gotta remove this. if you resurrect in a deadly place (like inside an object) then your corpse drops the target locator. This is very bad.
         --global.object[2].add_weapon(target_locator, force)        -- test       -- target_locator     -- for some reason, sometimes it makes an extra NPC with a target locator.
         --current_object.delete()
         hide_body()       -- changed from delete v23 so that dead survivor spectators can still view if another player resurrects their body.
      end
   end
end


-- Weirdness.
-- 1) the 'current_object.player[1]' isn't 'no_player' even after the player quits, so the corpse's number[5] continues increasing. Maybe that's expected.
-- 2) the corpse doesn't hide after the white NPC spartan resurrection occurs. the corpse is global.object[2] and the hide_body function should plainly hide it. don't get why it didn't. Was this a one-time glitch or always?
-- 3) the bomb created for the NPC biped didn't get set hidden and didn't get pikcup permissions disabled.
-- I dunno man. (3) could be just the host ran out of scripted objects, but I see no reason at all why (2) happened. It should have spawned a hill marker and attached the corpse to it. No way around it.





---- troubleshooting
--global.number[8] = 0
--for each object do
   --global.number[8] += 1
   --for each player do
      --script_widget[0].set_text("%n", global.number[8])        
      --script_widget[0].set_visibility(current_player, true)                
   --end
--end



------- nesting conventions
-- Each biped's player[0] is its owner.
-- An infectable biped will be team[0]  (or maybe neutral team). once infected, the dead biped will instantly change to a different team (either team[1] or team[2])
-- A dead biped's player[1] is the player which WILL occupy it once ready       -- might not be needed in the end.
-- A skull's player[0] is its daddy
-- A player's object[1] is a skull which very recently attacked it.        -- I might add a sort of timer to give it like a 1 sec blanking timer.






-------------------------------
----- Bugs to be fixed  -------
-------------------------------

-- when parasite purge happens, every skull on the map (under normal jumping speed) jumps in same direction. not sure if this only happens when there are no enemy spartans on map.

-- elites don't get given their random weapon. I looked into code & figured out why but it was awkward to fix. can't remember. something to do with how it sets global.object[3] = global.object[2].

-- resurrecting hold a weapon

-- ideally better flood appearances

-- parasites sometime kill themselves on their own thrown grenade for leap. I think coz they detach, the grenade bumps them, it kills them.

-- sometimes a combat form resurrects itself on death. not sure why. might be when you resurrect the first time, you stay able to resurrect afterwards.

-- flood growth never ends

-- if you resurrect before body hits ground, you fly.

-- multiple parasites can embed same biped until a resurrecting player has been chosen.

-- parasite choice is doesn't always use most recent. even when ejecting sometimes.

-- combat soemtimes gets its sword deleted randomly mid life. i think it happens a random amount of time after first equipping the sword.

-- entering resurrecting corpse while your carrier body is inflating is bad. when you finish to resurrect, you die instalty "fall to your death" and camera goes to loadout camera.

-- carrier respawning on a weapon gains the weapon permanently




-------------------------------
------- Finished  ---------
-------------------------------
-- Ranged form appearance

-- Ranged form transformation

-- Stalker form appearance

-- leap proximity check

-- map placed parasite spawn points

-- no downed weapon


-------------------------------
------- Still to add  ---------
-------------------------------


------------ Necessary -----------



-- Tank form appearance

-- hud widgets, progress bars, kill feed messages

-- ability cooldowns

-- player body infection cleanup

-- fall damage resistance

-- better flood growth

-- clean up ranger-stalker

-- multiplayer dynamic growth (probably)

-- correct multiplayer writhing

-- fall damage resistance

-- power class bonuses

-- 



------------- Optional -----------

-- disarming

-- flood claw

-- crouch checks

-- gravemind hopping

-- ejection (and figure out when it happens)

-- map territory timer control, compulsory territories

-- parasite jockies

-- player parasite embedding

-- play dead

-- Guardian oracle

-- sentinel 3-way infection

-- resurrect with most recent weapon





----- Redundancies

-- biped.number[0] and biped.number[7] both used, we only need one or the other. will just take a bit of time and care to switch to one system

-- can change all skull to number[7] == 666, and can streamline it even more by giving the skulls their own unique label. This would save tons of script if you ever want to find random skull too.

-- can function the player and AI skull embedding

-- unecessary random loadout camera, fire particles, other.


-- Biped team effects testing. changes hand appearance, changes pickup permissions, messes with other game features.
----- bottomline is bipeds don't like it when you change their team. they behave weirdly, and usually resist changing. if you change your current biped's team, it change change you hand appearance.
--for each object do
   --if current_object.is_of_type(spartan) then
      --global.number[10] = current_object.health
      --if global.number[10] == 0 then
         --current_object.team = team[1]
      --end
   --end
--end
--for each player do
   --global.object[2] = current_player.biped
   --global.object[6] = current_player.try_get_weapon(primary)
--if not global.object[6].is_of_type(magnum) then
  -- global.object[2].team = team[0]
--end
--if global.object[6].is_of_type(magnum) then
   --global.object[2].team = team[1]
--end
--if global.object[6].is_of_type(assault_rifle) then
   --global.object[2].team = neutral_team          -- no_team           -- you should try team[3]
--end
--end



------------ Spawning flood biped NPCs for aesthetic testing








------------ to do
-- frag grenades (adding and subtracting)
-- dropped frag grenades cleanup
-- fall damage resistance
-- ability cool downs
-- ability hud info

-- corpse flood growth. big.
-- flood appearance streamlining and tidying.
-- fix power class carrier

-- power class buffs: script-doubled hp for all, faster movement traits for parasite


----------- improvmements & streamlining
-- look through gamergotten documentation for better floor/airborn check
-- add gamergotten's corpse syncing system. I think it's attach-detach a bomb to every corpse regularly and attach-detach corpse to it, say 2x per sec.
-- script hardwired flood biped max_health.


---------- fixes
-- eject takes doesn't give you parasite from new tick.
-- delete or kill elite biped on stalker death.
-- brute's secondary sword sometimes dissappears. not sure why or when. i think maybe the dropped one is garbage collecting and/or getting crushed by the wall climbing grid.
-- purple team scale object still has collision. dunno why.       when fixed, use sound_emitter_alarm_2 instead of flag_stand.

-- ideally do a HOST wall proximity check for leap. ouch. you'll need to figure out the most efficient way to fucntion it all and get host to do the same check. 
------- otherwise you can leap while on inclines like the globe in Halo 3 Control Room. 
------- actually still might not be enough to get bottom incline jump working there coz it's too shallow for wall climb. But at least it would allow leap from wall climb, 



---- NPC carrier ballooning      stest
--for each object do
   --if current_object.number[7] == 4 then
      --global.number[10] = current_object.health
      --if global.number[10] == 0 then
         --current_object.number[7] = 14
      --end
   --end
--end

--
--for each object do
   --if current_object.is_of_type(elite) or current_object.is_of_type(spartan) then
      --current_object.set_waypoint_visibility(everyone)
      --current_object.set_waypoint_text("%n", hud_target_object.number[7])
   --end
--end


-- fireteam spawning for flood players

-- brute has way way too much health

-- 


-- Jump Strength 
-- original description (2 lines too long)
--The force of AI parasite jumps. Generally, Strength 1 produces campaign-accurate AI with consistent move speed which tend to clump into predictable groups. They are also better at climbing hills & walls. Strength 2 produces chaotic, variable speed AI with hard-to-predict jump heights and directions which tend to spread out, flank players, and fight as individuals. Recommendations:
--1) For disciplined AI, use Strength 1, high Speed (10 or 12). Use low Cooldown (optimally 5 to 10). Better climbers.
--2) For chaotic AI, use Strength 2, low Speed (6), and any Cooldown. Better jump scares.





-- Halo 3 control room description
-- Carve through Flood to light the ring & finish the fight! Map by CleanserOfNoobs & Rabid MagicMan. Use Rabid's Flood Inundation

-- Kye Corrupted Archive description
-- Myriad access chutes now spread the very thing this Ring was built to destroy. Map: GreenIV. Edits: Rabid. Use "Flood Inundation"     -- too long.    -- circulate
-- Forerunner access chutes now spread the very thing they built this Ring to destroy. By GreenIV + Rabid. Use "Flood Inundation"
-- Sentinel access chutes now spread the very thing they were built to destroy. Map: GreenIV. Edits: Rabid. Use "Flood Inundation"




---- keywords
-- mfix = something which will probably need fixing or changing for multiplayer
-- stest = something which is only here for testing in singleplayer. needs to be removed in the end.
-- finalpass = something to remove or add when you finish the gametype.
-- object saving = somewhere that you could change to save number of objects, to prevent map overloading.
-- redundancy = somewhere you can change to save script space.
-- luxury = something which is gravy/unimportant feature which can be removed for script space.
-- parasite OR skull = something to do with infection skull ai
-- crashes/crashing = something likely to cause crashing in multiplayer




-- Gravemind Sponsors (Major funding of this Flood gametype): IVOLUKE, II Phi, HenryBac0n, SteadyLake0, SearingLine129, Seanonix, Tito Cereal, Sentiguardian, Echo XVII, Hmbii
-- All sponsors: it takes an immense amount of time & work for me to produce these mods. They wouldn't exist without your funding. x
-- If you love this gametype,  p l e a s e  consider sponsoring my work so I can keep making more!!





--- best spacing:
--Schwarm-     Form      
--         Größe %n/%n



-- Awakened Parasite
-- Erwachter Parasit
-- Parasite Réveillé
-- Parasito despierto
-- Parassita Risvegliato


-- Melee = Assimilate a human     -- assimilate "(of the body or any biological system) absorb and digest (food or nutrients)."   or    "become absorbed and integrated into a society or culture."
-- Melee = Transfigure a host     -- transfigure "transform into something more beautiful or elevated."
-- Melee = Kill + Steal a Body     
-- Melee = Kill + Commandeer     
-- Melee = Kill + Convert
-- Melee = Kill + Assimilate/Transfigure


-- Mutating and Reanimating...
-- Transfiguring Raw Biomass...



----- Outstanding changes to make
-- ideally swarm form starts with half its max size. It takes a lot of waiting when you're an alpha to get up to strength.    -- not enough space, but bigger swarms indirectly buffed by < 25% infected parasite chewing
-- ideally disable parasite popping when < 25% infected to make the game challenging in co-op mode and in small lobbies.      x
-- try out half-ammo machine_gun_turret   OR    nerf it so it drops     OR    weaken loadout gear                             -- drops turret on contact.
-- maybe remove pickup exploit from plasma_turret and power_core
-- maybe fix red_reticle spartan persisting if a player quits.
-- maybe investigate why resurrect soemtimes instakills the player.
-- maybe remove/hide the machine_gun_turret loadout.     x
-- hide dropped cores better.



-- einen Wirt        -- de
-- un hôte           -- fr
-- un hospedador     -- es
-- un ospite         -- it


-- If enabled, AI parasites die if they touch a shielded player. Popping parasites are more effective against vehicles & turrets, non-popping are more effective against infantry. Recommendations: if enabled, set parasite shield damage to 40. If disabled, set parasite shield damage to 2 or 1.



-- Traits applied to all survivors when more than 80% of the lobby's players are infected (2 infected per 1 survivor).
-- These traits are applied to all survivors when more than 80% of the lobby's players are infected (by which point there are 2 infected per 1 survivor). This is intended to buff the survivors for dynamic balance.



-- rocket flood costs -3 conditions and -5 actions.  Quite a lot for an extremely rare troll/meme event.


-- The force of AI parasite jumps. Strength 1 makes AI with campaign-like movements which tend to clump into groups. Strength 2 produces harder AI with chaotic, hard-to-predict jump heights & directions which tend to spread out, flank players, and fight as individuals. Recommendations: for disciplined AI, use Strength 1, Speed 10 or 12, Cooldown 5 to 10. For scary chaotic AI, use Strength 2, Speed 6, any Cooldown.



-------------------------------------------------------------------
-------- Luxury parts you could remove for space -----------------
-------------------------------------------------------------------
-- 1) Sudden death and grace time.
--------- Things you can remove for space or make more actions / luxury and semi-redundant sections.
-- Waypoint on the Siren object on objectives.     Saves 6-8 actions, and you'd only lose the defense icon that's it.
-- Corpse infection for swarm form.       Not really needed for balance anymore, and it would save a handful of actions (expecially if you reword the possess function to be specific for the infection form). 
-- 30 second grace period, and cheapen late joiner infection and initial spawn point killing.      There are places throughout the script which need to account for late joiners sometimes being human. Look at Lethal Company for cheap late joiner infection.




-- v17 chanage 'weak standard issue' trait set vehicle usage back to ____